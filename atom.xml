<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>某科学的贝壳</title>
  
  <subtitle>一个贝壳的博客</subtitle>
  <link href="https://blog.ning.moe/atom.xml" rel="self"/>
  
  <link href="https://blog.ning.moe/"/>
  <updated>2025-03-02T07:28:59.609Z</updated>
  <id>https://blog.ning.moe/</id>
  
  <author>
    <name>shell</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【记】第一次收发信</title>
    <link href="https://blog.ning.moe/posts/First-sending-and-receiving-mail/"/>
    <id>https://blog.ning.moe/posts/First-sending-and-receiving-mail/</id>
    <published>2025-02-28T10:08:52.000Z</published>
    <updated>2025-03-02T07:28:59.609Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于纸质信件，在本次亲历收发过程之前，我的记忆始终蒙着一层雾霭。作为Z世代的一员，即便频繁使用电子邮件，却总觉得这种数字信笺与传统书信都带着某种时代滤镜。朋友意外收到三封来自英国电信商<code>giffgaff</code>的平信，犹如推开了一扇通往古典通信艺术的暗门。我们相约以国内平信互寄，恰逢几位三月寿星好友生辰将近，索性决定批量寄送这份手写的温度。</p><h1 id="寄信"><a href="#寄信" class="headerlink" title="寄信"></a>寄信</h1><p>邮局之旅远比想象中简单，倒是寻找大学收发室成了隐藏关卡（这个伏笔将在收信时引发连锁反应）。即便存在收发室，在这个即时通讯时代，其功能大概也仅剩被动收件了。业余无线电 X 中国邮政 战略合作伙伴，可惜我尚未取得业余无线电操作证（火腿族入门考试究竟何时重启啊！）。现代邮政服务确实便捷许多，不再强求专用邮封，理论上任何容器都能承载心意——<a href="https://www.bilibili.com/video/av113100816777685/" rel="external nofollow noreferrer">B站甚至有UP主用高铁清洁袋改造成信封</a>，堪称行为艺术。</p><p>原计划将信件投入街边邮筒，但两封挂号信让我不得不走进邮局。当13封信件摊在柜台时，连自己都惊讶于这份执着。最惊艳的是邮戳加盖仪式：工作人员手持铁锤敲击邮戳的刹那，时光仿佛倒流三十年。在电子印章普及的今天，这种保留原始机械美感的操作，俨然是活着的邮政博物馆。</p><p>原计划将信件投入街边邮筒，可是有两封信件需要寄挂号，那么顺便直接拿过去吧，一共13封信件，不知道为什么写着写着就这么多了。顺手还集了一个邮戳，最惊艳的是邮戳加盖仪式：工作人员手持铁锤敲击邮戳的刹那，时光仿佛倒流三十年。在电子印章普及的今天，这种保留原始机械美感的操作，俨然是活着的邮政博物馆。</p><table><thead><tr><th><img src="https://img.misaka.pics/ShellBlogImg/1/2025/03/01/67c2c3e5958c7.webp" alt="邮局信封.webp"></th><th><img src="https://img.misaka.pics/ShellBlogImg/1/2025/03/01/67c2c3fd2ba52.webp" alt="业务办理.webp"></th></tr></thead></table><h1 id="寻信"><a href="#寻信" class="headerlink" title="寻信"></a>寻信</h1><p>还记博主说过并不知道大学的收发室在哪里，Baka 博主甚至都开始怀疑学校还有没有收发室，很急啊 急急急 ，那就开始电话询问吧，但是真丢信了中国邮政是不负责的，应该不会丢吧？！</p><p>这里引出一个中国邮政的业务负责的板块，寄信的属于 营业厅不参与投递的业务的，投递业务有单独的投递部，那么就是说这个锅还是需要找投递部问问了，打了中国邮政电话，把地址给他给我一个投递部电话。</p><p>投递部的电话基本上异常难打，终于得知了平信他给我放在那里了，这才知道学校还是有一个收发室，实际过去是藏在一个小角落里面。</p><h1 id="收信"><a href="#收信" class="headerlink" title="收信"></a>收信</h1><p>兜兜转转终于拿到信了</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2025/03/01/67c2c86522448.webp" alt="收信.webp"></p></body></html>]]></content>
    
    
    <summary type="html">在数字时代，传统信件依然散发着独特魅力。本文记录了作者从寄信到找信的全过程，展现了复古邮局的别样温情与邮政体验。</summary>
    
    
    
    <category term="生活随想" scheme="https://blog.ning.moe/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="mail" scheme="https://blog.ning.moe/tags/mail/"/>
    
    <category term="平信" scheme="https://blog.ning.moe/tags/%E5%B9%B3%E4%BF%A1/"/>
    
    <category term="挂号信" scheme="https://blog.ning.moe/tags/%E6%8C%82%E5%8F%B7%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>【记】中国移动携号转网至中国电信</title>
    <link href="https://blog.ning.moe/posts/Mobile-Number-Portability/"/>
    <id>https://blog.ning.moe/posts/Mobile-Number-Portability/</id>
    <published>2025-02-06T09:57:01.000Z</published>
    <updated>2025-03-01T11:03:27.682Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>博主家曾全是中国移动，最长的一个号码已使用超过6000天。虽然一开始对于携号转网心存疑虑，但随着时间推移，尤其是19年将宽带迁移至电信后，我逐渐决定放弃中国移动。经过多次骚扰电话和长辈账户的额外费用，携号转网的想法再度提上日程。随着2025年携号转网政策实施五周年，流程已理论成熟，但实际操作过程中仍存在许多繁琐和问题。以下是我的转网经历与总结。</p><h1 id="携号准备"><a href="#携号准备" class="headerlink" title="携号准备"></a>携号准备</h1><p>在携号转网之前，首先需要确认自己的号码是否符合转网条件。你可以通过发送个人信息查询是否有资格办理。短信内容格式为：</p><blockquote><p>CXXZ#用户名#证件号码</p></blockquote><p>把上面的按照你的个人信息填好，发送至你现在的运营商(移动:10086、电信:10001、联通:10010)，基本上会有以下情况，如果同意那么准备阶段就已经结束了，如果没有就先打对应的运营商电话(移动:10086、电信:10001、联通:10010)，询问携号转网有影响的业务虽然一般业务取消是次月生效，但是如果解除了你可以再试试能否有资格携号转网，一般都是取消业务直接就可以了。</p><table><thead><tr><th>【携号转网告知提醒】尊敬的客户，您好！您的号码有在网协议“XXX活动（1年）”影响携号转网办理。详询10086。【中国移动】</th><th>【携号转网告知提醒】尊敬的客户，您好！您的号码满足携转条件，如需办理携号转网服务，请携带有效身份证件前往拟携入运营企业当地营业厅办理。受欠费、在网协议等因素影响，携转资格可能发生变化，建议办理前再次查询。详询10086。【中国移动心级服务，让爱连接】</th></tr></thead></table><h1 id="携入准备"><a href="#携入准备" class="headerlink" title="携入准备"></a>携入准备</h1><p>这个问题就开始比较棘手了，因为各地区的规定可能并不一样，一般情况下按照工信部发布的携号转网是可以直接去线下的营业厅进行办理的，但博主遇到的确实以各种理由延长或拒绝受理携号入网的。按照 <a href="https://www.gov.cn/xinwen/2019-11/11/content_5450928.htm" rel="external nofollow noreferrer">工业和信息化部关于印发《携号转网服务管理规定》的通知</a> 第九条第一小项：无正当理由拒绝、阻止、拖延向用户提供携号转网服务。</p><p>博主被告知的是没有名额需要预约，并且需要到下个月的8号，博主是2月4号去带长辈过去办理的，相当于等一月，而且预约并不能线上或者给营业厅打电话，必须本人携带身份证进行预约，经与工作人员沟通确认相关服务细则，并告知并没有，随后带着长辈先去逛逛商业街，给电信进行申请工单，到2月6号才被告知才可以进行携号转网，但是还只能先转入两个7号再转入一个，经过一系列的撕扯，最终他们同意6号当天进行转入3个。</p><p>所以这种东西建议还是去实地考察以下，毕竟就算一个省，不同地区都不一样，例如博主江苏省南京市携号转网，就没有预约和名额这个问题，但是博主家的市就有这个问题。</p><h1 id="进行携入"><a href="#进行携入" class="headerlink" title="进行携入"></a>进行携入</h1><p>随后6号去到营业厅，申请转移码,根据下面的个人信息填好，发送至你现在的运营商(移动:10086、电信:10001、联通:10010)。</p><blockquote><p>SQXZ#用户名#证件号码</p></blockquote><p>差不多是下面这种格式，转移码有效期一个小时</p><blockquote><p>【携号转网告知提醒】尊敬的客户，您好！您申请的携出授权码为464036，有效期到2025-02-06 12:03。您需在有效期内携带有效身份证件前往拟携入运营企业当地营业厅办理，逾期办理需重新申请授权码。详询10086。【中国移动心级服务，让爱连接】</p></blockquote><p>以及漫长的等待差不多一个号码转入需要花费20分钟，以及一个小时只能转移一个号码，什么意思呢？举个例子:</p><blockquote><p>例如 ：张三先生手里面有2个号码转入XXX运营商，例如他是9点 ~ 10点区间内转移的第一个号码，那么下次转移最快需要在10 ~ 11点区间进行转移，像博主转移三个号码但是A先生是有两个号码B女士是一个号码，那么实际上A先生需要花费两个小时进行转移，而B女士只需要不受等待期印象，因为系统只认你证件。</p></blockquote><p>所以假设有很多的号码尽量转移给不同的亲属名下，会加速转移的进程。</p><p>此外运营商同步信息是1个小时同步一次，例如 10~11点区间写好转移成功，那么新的sim卡会在12点之后才可以进行使用，再次之前您的旧卡仍然可以正常使用。</p><p>以及测试以下新卡启动服务之后拨打电话是否正常，以博主的举例：移动转电信，那么去找朋友或者亲戚有移动的手机号以及电信的手机号进行拨打是否正常，防止会出现这个新闻：<a href="https://news.qq.com/rain/a/20240528A071H300" rel="external nofollow noreferrer">同一号码竟有两家运营商用户同时在用？江苏省通信管理局现场回应</a></p><h1 id="旧运营商花费取出"><a href="#旧运营商花费取出" class="headerlink" title="旧运营商花费取出"></a>旧运营商花费取出</h1><p>在 <a href="#%E8%BF%9B%E8%A1%8C%E6%90%BA%E5%85%A5">进行携入</a> 章节有说过信息同步是1个小时，也就是说在你号码正式生效之后你就可以去老的运营商营业厅，携带有效证件进行退花费，博主这边移动退给你花费是工作人员直接微信扫码给你。但博主也搜索到案例说是次月6号之后，才可以办理，博主打算只是去碰碰运气，后面就详细询问了移动的工作人员，表示需要至少1个整点左右，不然系统不太能同步数据，基本上你这边转网成功一个整点后是可以退的。</p><h1 id="总结以下"><a href="#总结以下" class="headerlink" title="总结以下"></a>总结以下</h1><p>虽然携号转网政策已经实行五年之久了，本想着处理流程可能会进行优化，但是实际进行转网之后遇到各种问题，例如博主所在的城市的电信有着自己的小规定，但是网上也只有一篇搜狐的文章： <a href="https://www.sohu.com/a/782558519_121282114" rel="external nofollow noreferrer">记者调查：携号转网，不是想转就能转？</a> 以及线上貌似可以随便办理，但是没有办法进行复杂的选择例如电信只能 35元或者更贵的套餐，并没有办法进行复杂操作，以及携号转网受理时间之久，3个号不算等待期，只算工作人员进行受理，平均一个手机号需要20~30分钟的处理时间，说一比较坏的如果客服全部提交内容但正好已经到了下一个整点，就要在等一个整点了。只能说携号转网确实是好的，但是实际执行还是很歪歪扭扭的，以及网上并没有这种坑的存在，甚至这种等待期的整点生效也很少文章会提到，大多数的还是转发，多么简答的复制粘贴，只告诉你只需要发送两个短信就可以了。emmmm</p><p>好吧最后希望我的文章帮助更多的想进行携号转网，另外既然你看到这里了，我就说一个小秘密，其实我电信工单建立并没有处理我的诉求，后通过工信部用户申诉渠道推动问题解决(<a href="https://yhssglxt.miit.gov.cn/web/" rel="external nofollow noreferrer">工业和信息化部电信用户申诉受理中心</a>)，感谢主管部门的协调处理。</p><h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>本篇文章仅为博主个人在携号转网过程中的经历与分享。文章中的所有操作流程、规则及细节仅代表博主所在地区的实际情况，可能会因地区、运营商、时间等因素有所不同，具体流程请根据个人所在地区及运营商的规定进行咨询和确认。</p><p>博主并未接受任何公司或第三方的赞助，文章内容完全基于个人经验及公开可获取的信息。请读者在办理携号转网时，遵循官方运营商和相关部门的最新政策与指导，谨慎处理个人信息，并确保所提供的操作符合当地的法律法规。</p><p>如有任何关于携号转网的疑问，建议直接联系各运营商或相关主管部门，以获取更加准确和及时的帮助。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>工业和信息化部关于印发《携号转网服务管理规定》的通知：<a href="https://www.gov.cn/xinwen/2019-11/11/content_5450928.htm" rel="external nofollow noreferrer">https://www.gov.cn/xinwen/2019-11/11/content_5450928.htm</a><br>记者调查：携号转网，不是想转就能转？：<a href="https://www.sohu.com/a/782558519_121282114" rel="external nofollow noreferrer">https://www.sohu.com/a/782558519_121282114</a><br>同一号码竟有两家运营商用户同时在用？江苏省通信管理局现场回应：<a href="https://news.qq.com/rain/a/20240528A071H300" rel="external nofollow noreferrer">https://news.qq.com/rain/a/20240528A071H300</a><br>工业和信息化部电信用户申诉受理中心：<a href="https://yhssglxt.miit.gov.cn/web/" rel="external nofollow noreferrer">https://yhssglxt.miit.gov.cn/web/</a></p><p>封面图来自中国电信官网：<a href="https://www.189.cn/" rel="external nofollow noreferrer">https://www.189.cn/</a></p></body></html>]]></content>
    
    
    <summary type="html">在这篇文章中，博主分享了个人在中国移动携号转网至中国电信的亲身经历，从准备步骤到遇到的各种问题与解决方法。虽然携号转网政策已经实施多年，但实际操作仍充满挑战。通过这篇文章，你将了解如何顺利完成携号转网、避开常见陷阱，并掌握一些实用的小技巧。如果你正在考虑转网，这篇文章一定能为你提供宝贵的参考！</summary>
    
    
    
    <category term="生活随想" scheme="https://blog.ning.moe/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="携号转网" scheme="https://blog.ning.moe/tags/%E6%90%BA%E5%8F%B7%E8%BD%AC%E7%BD%91/"/>
    
    <category term="中国电信" scheme="https://blog.ning.moe/tags/%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1/"/>
    
    <category term="中国移动" scheme="https://blog.ning.moe/tags/%E4%B8%AD%E5%9B%BD%E7%A7%BB%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>2024总结</title>
    <link href="https://blog.ning.moe/posts/2024-Annual-Summary/"/>
    <id>https://blog.ning.moe/posts/2024-Annual-Summary/</id>
    <published>2024-12-31T04:00:00.000Z</published>
    <updated>2024-12-31T03:31:51.293Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>转眼间 2024 年就这样结束了，回顾过去这一年，似乎比往年多了一些亮点，也多了一些挑战。</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>经历了一年的耕耘，博客在 2024 年迎来了飞跃式的增长。</p><p>2024 年共计写了 12 篇文章其中阅读量最高的是 IkuaI 防火墙配置 IPv6 ，总阅读量达到了 1.5k，其中 Google 是最大的流量来源。其次是 创建递归 DNS 服务，总阅读量为 1.32k。</p><p>全年本站从 2024 年的完整数据统计来看，共计收获了 PV 26.5k，UV 11k。相比往年，流量实现了惊人的增长，访客数量增长了  405 %，PV 增长了  307%，这离不开每位读者的支持和热爱。</p><p>以下是全年 PV 和 UV 数据的柱状图：</p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/12/31/67735da18f9d8.webp" alt="2024-Blog-PV&amp;UV-Date.webp" style="zoom:50%;">  <blockquote><p>为什么数据增长幅度如此之大？<br><del>因为今年认真写了好多技术文章</del></p></blockquote><p>在内容优化和搜索引擎的加持下，流量主要来源于 Google（占比 32%）和 Bing（占比 12%）。同时，社区平台如 V2EX、各类博客推荐站点也贡献了不少流量，再次感谢大家。</p><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>2024 年，我在博客内容上更加聚焦于网络、开发工具和技术教程，包括：</p><ul><li><strong>IkuaI 防火墙配置</strong></li><li><strong>Cloudflare 验证码整合实践</strong></li><li><strong>DNS 服务</strong></li></ul><p>虽然只是一些个人的尝试和探索，但希望这些文章能够对有相似需求的朋友有所帮助，也算是记录自己学习过程的一部分。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>2024 年的故事就此落幕，这一年里，我不仅在博客上投入了更多精力，也见证了它从沉寂到焕发新生的过程。同时，也遇到了更多有趣的人和事，在线下和线上都感受到更多连接的意义。</p><p>2025 年的故事即将开启，新的一年里，我希望能继续探索和尝试不同的事物。或许是去到未曾踏足的地方，感受不同的风土人情；或许是深入钻研更多技术领域，为自己的学习旅程增添新的色彩。而博客，依然是记录我这些成长和感悟的地方，虽然只是业余分享，但希望能继续与大家一起学习、交流、成长。</p><p>感谢每一位读者的陪伴，新的一年，让我们一起迎接新的冒险！</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;转眼间 2024 年就这样结束了，回顾过去这一年，似乎比往年多了一些亮点，也多了一些挑战。&lt;/p&gt;
&lt;h1 id=&quot;博客&quot;&gt;&lt;a href=&quot;#博客&quot; class=&quot;headerlink&quot; title=&quot;博客&quot;&gt;&lt;/a&gt;博客</summary>
      
    
    
    
    <category term="生活随想" scheme="https://blog.ning.moe/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="总结" scheme="https://blog.ning.moe/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="2024" scheme="https://blog.ning.moe/tags/2024/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用pg_restore 出现Segmentation fault (core dumped)</title>
    <link href="https://blog.ning.moe/posts/docker-postgresql-Segmentation-fault/"/>
    <id>https://blog.ning.moe/posts/docker-postgresql-Segmentation-fault/</id>
    <published>2024-12-21T10:58:21.000Z</published>
    <updated>2024-12-31T03:33:34.948Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>最近，在将 <strong>Authentik</strong> 从版本 <code>2024.6.3</code> 升级到 <code>2024.12.0</code> 的过程中， <strong>Authentik</strong>新版本需要升级 <strong>PostgreSQL</strong> 数据库版本，从 <code>12</code> 升级到了 <code>16</code>。整个升级过程总体较为顺利，但在尝试通过 <code>pg_restore</code> 恢复数据时，却意外遇到了<strong>（segmentation fault）</strong>。</p><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a><strong>问题背景</strong></h2><p>升级步骤大致如下：</p><ol><li><p>✅ 使用 Docker 容器管理 PostgreSQL 和 Authentik。</p></li><li><p>📦 在升级前，通过以下命令将 PostgreSQL 数据库的内容备份到宿主机：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -ti &lt;容器id&gt; pg_dump -Fc -U &lt;数据库用户名&gt; &lt;数据库名&gt; &gt; db.dump</span><br></pre></td></tr></tbody></table></figure></li><li><p>🛠️ 安装新的 Authentik 和 PostgreSQL 容器。</p></li><li><p>🔄 尝试使用以下命令恢复数据：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp db.dump &lt;容器id&gt;:/db.dump</span><br><span class="line">docker exec -ti &lt;容器id&gt; pg_restore -U &lt;数据库用户名&gt; -c -d &lt;数据库名&gt; /db.dump</span><br></pre></td></tr></tbody></table></figure></li></ol><p>然而，在执行恢复时，窗口没有报错，也没有任何恢复效果。随后，我进入容器，手动执行 <code>pg_restore</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;容器id&gt; bash</span><br><span class="line">&lt;容器id&gt;:/# pg_restore -Fc -h localhost -U &lt;数据库用户名&gt; -d &lt;数据库名&gt; /tmp/db.dump</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></tbody></table></figure><p>这时，命令直接报错：**Segmentation fault (core dumped)**。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h2><p>为了解决这个问题，我在<code>stackoverflow</code> 中找到了，关键在于避免通过 <code>stdout</code> 传递二进制数据。以下是改进后的备份和恢复步骤。</p><h3 id="1-正确备份方法"><a href="#1-正确备份方法" class="headerlink" title="1. 正确备份方法"></a><strong>1. 正确备份方法</strong></h3><p>📤 直接在容器内部生成备份文件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -ti &lt;容器id&gt; bash -c 'pg_dump -Fc &lt;数据库名&gt; -U &lt;数据库用户名&gt; &gt; /tmp/db.dump'</span><br></pre></td></tr></tbody></table></figure><p>📥 然后将备份文件从容器复制到宿主机：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp &lt;容器id&gt;:/tmp/db.dump ./db.dump</span><br></pre></td></tr></tbody></table></figure><h3 id="2-正确恢复方法"><a href="#2-正确恢复方法" class="headerlink" title="2. 正确恢复方法"></a><strong>2. 正确恢复方法</strong></h3><p>📤 将备份文件复制回容器：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp db.dump &lt;容器id&gt;:/tmp/db.dump</span><br></pre></td></tr></tbody></table></figure><p>🔄 在容器内恢复数据：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -ti &lt;容器id&gt; pg_restore -U &lt;数据库用户名&gt; -c -d &lt;数据库名&gt; /tmp/db.dump</span><br></pre></td></tr></tbody></table></figure><h2 id="总结和建议"><a href="#总结和建议" class="headerlink" title="总结和建议"></a><strong>总结和建议</strong></h2><p>在升级 Authentik 和 PostgreSQL 的过程中，我因为使用不正确的备份和恢复方式，导致了 <code>pg_restore</code> 报错分段错误。这次经验让我认识到：</p><ul><li>⚠️ <strong>备份和恢复二进制数据时要小心处理传输环节，尤其是通过管道或</strong> <code>**stdout**</code> <strong>的传输方式</strong>。</li><li>✅ 更安全的做法是直接在容器内生成和使用备份文件，减少中间数据传输带来的风险。</li></ul><p>希望这篇文章能帮助到和我一样在升级 PostgreSQL 和 Authentik 的过程中遇到问题的朋友。如果你也有类似问题或更好的解决方法，欢迎在评论中讨论！</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>stackoverflow:<a href="https://stackoverflow.com/questions/63934856/why-is-pg-restore-segfaulting-in-docker" rel="external nofollow noreferrer">https://stackoverflow.com/questions/63934856/why-is-pg-restore-segfaulting-in-docker</a></p></body></html>]]></content>
    
    
    <summary type="html">解决在使用 Docker 管理 PostgreSQL 数据库时，通过 pg_restore 恢复数据遇到分段错误（Segmentation fault）的经验分享。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="2024" scheme="https://blog.ning.moe/tags/2024/"/>
    
    <category term="PostgreSQL" scheme="https://blog.ning.moe/tags/PostgreSQL/"/>
    
    <category term="Docker" scheme="https://blog.ning.moe/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>应对恶意评论：从 Twikoo 到 Artalk 的防护之路</title>
    <link href="https://blog.ning.moe/posts/Management-Commentary/"/>
    <id>https://blog.ning.moe/posts/Management-Commentary/</id>
    <published>2024-11-15T08:53:39.000Z</published>
    <updated>2024-12-31T03:33:44.708Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>起初，博客使用的评论系统是 <code>twikoo</code>，它小巧实用，功能虽然简洁，但已包含主要的评论功能、邮箱通知以及反垃圾评论机制，评论数据以 <code>json</code> 文件存储。这对我这样的小站来说，本已绰绰有余。然而，近一个月以来，某人莫名开始恶意评论，甚至模仿其他人的留言反复发送（起初我还以为是 <code>twikoo</code> 的问题）。本以为只是几天的恶作剧，没想到持续了整整一个月。在此，我真心佩服这位恶意评论者，竟然愿意在他的人生中耗费如此多的时间和精力，专注于折腾我这个小破站。</p><table><thead><tr><th><img src="https://img.misaka.pics/ShellBlogImg/1/2024/11/15/67370eb853aa7.webp" alt="恶意评论-1.webp"></th><th><img src="https://img.misaka.pics/ShellBlogImg/1/2024/11/15/67370eb85a43b.webp" alt="恶意评论-2.webp"></th></tr></thead><tbody><tr><td><img src="https://img.misaka.pics/ShellBlogImg/1/2024/11/15/67370eb877da9.webp" alt="恶意评论-3.webp"></td><td><img src="https://img.misaka.pics/ShellBlogImg/1/2024/11/15/67370eb8d753a.webp" alt="恶意评论-4.webp"></td></tr></tbody></table><h1 id="整治"><a href="#整治" class="headerlink" title="整治"></a>整治</h1><p>我首先将评论系统从 <code>twikoo</code> 更换为 <code>artalk</code>，因为 <code>twikoo</code> 使用 <code>POST</code> 方法获取评论，而我的初衷是阻止恶意评论的同时尽量不影响正常用户。更换为 <code>artalk</code> 后，评论获取改为使用 <code>GET</code> 方法，同时我还设置了 <code>artalk</code> 的首次评论需经过审核。  </p><p>接着，我在 <code>Cloudflare</code> 中配置了 <code>WAF</code>（Web 应用防火墙），并添加了以下规则：  </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(http.<span class="property">host</span> eq <span class="string">"artalk.ning.moe"</span> and http.<span class="property">request</span>.<span class="property">uri</span>.<span class="property">path</span> eq <span class="string">"/api/v2/comments"</span> and ip.<span class="property">geoip</span>.<span class="property">asnum</span> eq <span class="number">13335</span> and http.<span class="property">request</span>.<span class="property">method</span> eq <span class="string">"POST"</span>)</span><br></pre></td></tr></tbody></table></figure><p>判断主机名，判断请求路径、判断 ASN 段 判断POST请求，如果全中，就无法进行评论。后续我会收录一些常见的免费代理的 <code>ASN</code> 段</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如果上述防护措施无意中影响了正常用户的评论体验，我深表歉意。作为一个小站，最初只是希望能有更多人来这里留言互动，因此并未做过多的防护设置。没想到遇到恶意刷评论的情况，不得不采取一定的措施来保护站点。感谢每一位支持和理解的小伙伴，你们的留言是这个小站继续前行的动力！</p></body></html>]]></content>
    
    
    <summary type="html">记录了一个小站从遭遇持续恶意评论到逐步优化评论系统的全过程，包括从 Twikoo 切换到 Artalk 和配置 Cloudflare WAF 的实际经验，希望为其他站长提供参考</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="2024" scheme="https://blog.ning.moe/tags/2024/"/>
    
    <category term="twikoo" scheme="https://blog.ning.moe/tags/twikoo/"/>
    
    <category term="Artalk" scheme="https://blog.ning.moe/tags/Artalk/"/>
    
  </entry>
  
  <entry>
    <title>改造宿舍网络</title>
    <link href="https://blog.ning.moe/posts/Modification-of-dormitory-network/"/>
    <id>https://blog.ning.moe/posts/Modification-of-dormitory-network/</id>
    <published>2024-10-26T02:31:29.000Z</published>
    <updated>2024-12-31T03:33:59.071Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>到了新学校了，最担心的还是宿舍的校园网，嗯非常的坑（校园网络是被一个平台垄断了，然后出口是三大运营商，需要办理对应的卡解锁网络出口），在用完我一个月的流量之后打算还是办理一张卡吧，其实在没办理看的时候我就收集了一下信息，学校使用的是<a href="https://www.ruijie.com.cn/cp/yyxt-yygl/samx/" rel="external nofollow noreferrer">锐捷认证的</a>，emmm 又是锐捷漏洞真多的，我尝试试了一下已知漏洞，好吧果然没用，再加上博主并不是安全的专业只会点皮毛而已。</p><p>既然后面办理完毕的校园网，折腾一下自动认证也不是不行。</p><p>后续介绍了一下自动认证的思路以及放上<a href="https://github.com/biliblihuorong/ZiJinCollege-AutoNetwork" rel="external nofollow noreferrer">源码</a>，还有增加了舒适度搞了一个路由器让室友也爽爽。</p><h1 id="校园网自动认证"><a href="#校园网自动认证" class="headerlink" title="校园网自动认证"></a>校园网自动认证</h1><p>这边先放上我写好的程序: <a href="https://github.com/biliblihuorong/ZiJinCollege-AutoNetwork" rel="external nofollow noreferrer">ZiJinCollege-AutoNetwork</a></p><p>连接校园网（网线和wifi），学校的认证页面IP是<code>172.21.2.10</code>通过浏览器抓包看到，先302到 <code>123.123.123.123</code>然后又200但是很明显url是跳转到了到<code>172.21.2.10</code>，但是这次访问uri多了很多参数，最后发现携带一个js的跳转。</p><table><thead><tr><th><img src="https://img.misaka.pics/ShellBlogImg/1/2024/10/26/671c5e07c345c.webp" alt="schoolnetwork-1.webp"></th><th><img src="https://img.misaka.pics/ShellBlogImg/1/2024/10/26/671c5e08e10ff.webp" alt="schoolnetwork-2.webp"></th></tr></thead></table><p>尝试登录发现就是一个很正常的表单，<code>queryString</code>的参数也就是刚刚跳转的，也是要必须携带的。</p><table><thead><tr><th><img src="https://img.misaka.pics/ShellBlogImg/1/2024/10/26/671c5e08448d4.webp" alt="schoolnetwork-3.webp"></th><th><img src="https://img.misaka.pics/ShellBlogImg/1/2024/10/26/671c5e09464b9.webp" alt="schoolnetwork-4.webp"></th></tr></thead></table><p>模拟一下<code>uri</code>的编码即可.</p><h1 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h1><p>其实很后悔，把家里面r2s的小开发板出了，毕竟需要要给op系统就行了到时候直接写一个bash 脚本，找了很久发现 <code>gl-mt3000</code> 的路由器，是满足我的需求的，出场是魔改的op系统运行ssh 并且保留原版op的luci 的web 页面，里面还带一个小风扇，可惜就是内存太小了。</p><p>简单配置了一下，放上我 Linux bash 脚本 。</p><table><thead><tr><th><img src="https://img.misaka.pics/ShellBlogImg/1/2024/10/26/671c5e0994959.webp" alt="schoolnetwork-5.webp"></th><th><img src="https://img.misaka.pics/ShellBlogImg/1/2024/10/26/671c5e0a2f380.webp" alt="schoolnetwork-6.webp"></th></tr></thead></table><p>还有内置的<code>adguadhome</code> <code>dns</code> 走一下加密doh。</p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/10/26/671c661e806ff.webp" alt="schoolnetwork-7.webp" style="zoom: 80%;"><p>目前这个这个小路由器带着14台设备进行上网温度70°（官方默认小风扇启动是75°</p><h1 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h1><p><del>什么时候校园网有v6啊啊啊啊啊。</del></p></body></html>]]></content>
    
    
    <summary type="html">我分享了如何改造大学宿舍的校园网络，通过自动认证和配置路由器，提升网络体验。文章详细介绍了校园网的认证流程、相关脚本，以及推荐的路由器配置，帮助同学们更好地应对校园网络的挑战。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="2024" scheme="https://blog.ning.moe/tags/2024/"/>
    
    <category term="OpenWrt" scheme="https://blog.ning.moe/tags/OpenWrt/"/>
    
  </entry>
  
  <entry>
    <title>在 Docker 环境中使用 Traefik进行反向代理</title>
    <link href="https://blog.ning.moe/posts/learn-traefik/"/>
    <id>https://blog.ning.moe/posts/learn-traefik/</id>
    <published>2024-10-05T04:51:17.000Z</published>
    <updated>2024-12-31T03:34:31.436Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于家里面要部署很多 <code>Docker</code> 服务，用 <code>Nginx</code> 反向代理属实麻烦，所以就有了本篇文章 <code>Traefik</code></p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/09/02/66d58750e396f.webp" alt="traefik-1.webp" style="zoom:33%;"><p><code>Traefik</code> 的logo 是一个<code>go</code>吉祥物进行指挥交通（流量）。</p><p>所以 <code>Traefik</code>的好处是自动发现服务，自动配置反向代理，以及自动续签SSL，以及不在需要对外暴露额外的端口了，宿主机自始至终之暴露 80 443 端口。但也有诸多问题例如它并不能像<code>Nginx</code> 一样可以灵活的配置反代一些程序，例如配置不在<code>Docker</code> 部署的程序，会有点麻烦，如果想我一样只是作为本地部署项目<code>Traefik</code> 仍然是一个不错的选择。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>在快速启动前，有必要说明一下，本教程是使用<code>CloudFlare</code> 作为域名ns进行申请泛域名证书，如果你想使用其他提供商，可以在 <a href="https://doc.traefik.io/traefik/https/acme/#providers" rel="external nofollow noreferrer">Traefik 的文档</a> 更改 <code>Provider Code</code>和 <code>Environment Variables</code> 这两个值，当然我会在本篇配置文件有注释提醒。</p><p>另外如果没有额外配置反代的需求（指不跑在docker的服务），需要建立<code>config.yml</code> 文件，当然还需要在<code>traefik.yml</code> 关闭注释。</p><h2 id="快速启动-Traefik"><a href="#快速启动-Traefik" class="headerlink" title="快速启动 Traefik"></a>快速启动 Traefik</h2><p>请按照一下文件目录创建文件，其中<code>acme.json</code>只需要创建文件即可（注意必须要交建立哦，config文件根据自己需求建立即可）</p><p>文件目录：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|   .env#文件配置</span><br><span class="line">|   docker-compose.yaml# docker-compose 文件</span><br><span class="line">|</span><br><span class="line">\---data</span><br><span class="line">        acme.json# SSL 文件</span><br><span class="line">        config.yml# 额外配置文件（配置额外反代例如宿主机的）</span><br><span class="line">        traefik.yml # Traefik 配置文件</span><br></pre></td></tr></tbody></table></figure><p><code>docker-compose.yaml</code> 文件：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">traefik:</span>  <span class="comment"># 定义名为 traefik 的服务</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">traefik:v3.0</span>  <span class="comment"># 使用 Traefik 的 v3.0 版本镜像</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">traefik</span>  <span class="comment"># 容器名称为 traefik</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span>  <span class="comment"># 容器自动重启，除非手动停止</span></span><br><span class="line">    <span class="attr">security_opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="literal">no</span><span class="string">-new-privileges:true</span>  <span class="comment"># 增加安全性，防止提权</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">traefik-net</span>  <span class="comment"># 连接到名为 proxy 的外部网络</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span>  <span class="comment"># 映射主机的 80 端口到容器的 80 端口 (HTTP)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">443</span><span class="string">:443</span>  <span class="comment"># 映射主机的 443 端口到容器的 443 端口 (HTTPS)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">443</span><span class="string">:443/tcp</span>  <span class="comment"># 映射主机的 443 TCP 端口到容器的 443 端口 (TCP 协议)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">443</span><span class="string">:443/udp</span>  <span class="comment"># 映射主机的 443 UDP 端口到容器的 443 端口 (UDP 协议)</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">CF_DNS_API_TOKEN_FILE:</span> <span class="string">${CF_DNS_API_TOKEN}</span>  <span class="comment"># 设置环境变量，使用 Cloudflare API 令牌，根据Traefik文档 选择你的服务提供商的token</span></span><br><span class="line">      <span class="attr">TRAEFIK_DASHBOARD_CREDENTIALS:</span> <span class="string">${TRAEFIK_DASHBOARD_CREDENTIALS}</span>  <span class="comment"># 设置环境变量，定义 Traefik 仪表板的凭据</span></span><br><span class="line">    <span class="attr">env_file:</span> <span class="string">.env</span>  <span class="comment"># 从 .env 文件中加载环境变量</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span>  <span class="comment"># 挂载主机的时间设置到容器，确保时间同步，且只读</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock:ro</span>  <span class="comment"># 挂载 Docker 的 socket 文件，允许 Traefik 访问 Docker API，只读</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/traefik.yml:/traefik.yml:ro</span>  <span class="comment"># 挂载本地的 traefik.yml 配置文件到容器内，只读</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/acme.json:/acme.json</span>  <span class="comment"># 挂载本地的 acme.json 文件，存储 SSL 证书信息</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/config.yml:/config.yml:ro</span>  <span class="comment"># 可选的配置文件挂载路径，若需要可取消注释</span></span><br><span class="line">    <span class="attr">labels:</span>  <span class="comment"># 设置 Traefik 的相关标签，用于路由和中间件配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.enable=true"</span>  <span class="comment"># 启用 Traefik 服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.traefik.entrypoints=http"</span>  <span class="comment"># 配置 HTTP 入口点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.traefik.rule=Host(`${TRAEFIK_DASHBOARD_HOST}`)"</span> <span class="comment"># 定义 Traefik 仪表板的访问规则</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.middlewares.traefik-auth.basicauth.users=${TRAEFIK_DASHBOARD_CREDENTIALS}"</span>  <span class="comment"># 为仪表板配置基本身份验证</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.middlewares.traefik-https-redirect.redirectscheme.scheme=https"</span>  <span class="comment"># 配置 HTTP 到 HTTPS 的重定向</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.middlewares.sslheader.headers.customrequestheaders.X-Forwarded-Proto=https"</span>  <span class="comment"># 添加自定义请求头</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.traefik.middlewares=traefik-https-redirect"</span>  <span class="comment"># 将重定向中间件应用到 HTTP 路由</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.traefik-secure.entrypoints=https"</span>  <span class="comment"># 配置 HTTPS 入口点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.traefik-secure.rule=Host(`${TRAEFIK_DASHBOARD_HOST}`)"</span> <span class="comment"># 定义 HTTPS 路由的访问规则</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.traefik-secure.middlewares=traefik-auth"</span>  <span class="comment"># 为 HTTPS 路由应用基本身份验证中间件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.traefik-secure.tls=true"</span>  <span class="comment"># 启用 TLS (HTTPS)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.traefik-secure.tls.certresolver=${NS_Domain}"</span>  <span class="comment"># 使用 DNS服务提供商 code 根据Traefik文档 选择你的服务提供商code</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.traefik-secure.tls.domains[0].main=${TLS_MAIN_DOMAIN}"</span>  <span class="comment"># 定义主域名</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.traefik-secure.tls.domains[0].sans=${TLS_SANS_DOMAIN}"</span>  <span class="comment"># 定义子域名通配符</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.traefik-secure.service=api@internal"</span>  <span class="comment"># 使用 Traefik 内部 API 服务</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">traefik-net:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">false</span>  <span class="comment"># 使用外部定义的名为 proxy 的网络</span></span><br></pre></td></tr></tbody></table></figure><p><code>.env</code> 文件:</p><figure class="highlight toml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .env 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CF API</span></span><br><span class="line"><span class="attr">CF_DNS_API_TOKEN</span>=</span><br><span class="line"></span><br><span class="line"><span class="attr">NS_Domain</span>=cloudflare <span class="comment">#根据你使用的DNS服务提供商 code 根据Traefik文档 选择你的服务提供商code</span></span><br><span class="line"><span class="comment"># 设置环境变量，定义 Traefik 仪表板的凭据 ，默认账户名密码：admin</span></span><br><span class="line"><span class="attr">TRAEFIK_DASHBOARD_CREDENTIALS</span>=admin:$<span class="variable">$2y</span>$<span class="variable">$05</span>$<span class="variable">$aOXINGgHfnZ</span>//t.kUs7o9ej3faUbj2yNxc8k3WVrBybFOxxaTsLTe</span><br><span class="line"></span><br><span class="line"><span class="comment"># Traefik Dashboard 域名</span></span><br><span class="line"><span class="attr">TRAEFIK_DASHBOARD_HOST</span>=dash.docker.localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># TLS 主域名和子域名</span></span><br><span class="line"><span class="attr">TLS_MAIN_DOMAIN</span>=docker.localhost</span><br><span class="line"><span class="attr">TLS_SANS_DOMAIN</span>=*.docker.localhost</span><br></pre></td></tr></tbody></table></figure><p><code>traefik.yml</code> 文件：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">api:</span></span><br><span class="line">  <span class="attr">dashboard:</span> <span class="literal">true</span>  <span class="comment"># 启用 Traefik 的仪表板，可以通过指定的路由访问</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">true</span>  <span class="comment"># 启用调试模式，输出更多的日志信息</span></span><br><span class="line"></span><br><span class="line"><span class="attr">entryPoints:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">":80"</span>  <span class="comment"># 定义 HTTP 入口点，监听 80 端口</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">redirections:</span></span><br><span class="line">        <span class="attr">entryPoint:</span></span><br><span class="line">          <span class="attr">to:</span> <span class="string">https</span>  <span class="comment"># 重定向 HTTP 请求到 HTTPS</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">https</span>  <span class="comment"># 使用 HTTPS 作为重定向的目标协议</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">https:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">":443"</span>  <span class="comment"># 定义 HTTPS 入口点，监听 443 端口</span></span><br><span class="line"></span><br><span class="line"><span class="attr">serversTransport:</span></span><br><span class="line">  <span class="attr">insecureSkipVerify:</span> <span class="literal">true</span>  <span class="comment"># 在与后端服务器通信时，跳过 TLS 证书验证（不推荐在生产环境中使用）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">providers:</span></span><br><span class="line">  <span class="attr">docker:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">"unix:///var/run/docker.sock"</span>  <span class="comment"># 指定 Docker API 的 socket 文件路径，Traefik 使用它来检测和管理 Docker 容器</span></span><br><span class="line">    <span class="attr">exposedByDefault:</span> <span class="literal">false</span>  <span class="comment"># 默认情况下，Docker 容器不会自动暴露给 Traefik，必须显式指定</span></span><br><span class="line">    <span class="attr">watch:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">filename:</span> <span class="string">/config.yml</span>  <span class="comment"># (已注释) 可选的文件提供者配置，用于从外部文件加载配置</span></span><br><span class="line">    <span class="attr">watch:</span> <span class="literal">true</span>  <span class="comment"># 允许 Traefik 自动监控和加载配置文件变化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">certificatesResolvers:</span></span><br><span class="line">  <span class="attr">cloudflare:</span> <span class="comment"># 使用 DNS服务提供商 code 根据Traefik文档 选择你的服务提供商code</span></span><br><span class="line">    <span class="attr">acme:</span></span><br><span class="line">      <span class="attr">email:</span> <span class="string">youremail@email.com</span>  <span class="comment"># 申请 ACME 证书时使用的电子邮件地址</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">acme.json</span>  <span class="comment"># 存储证书信息的文件路径</span></span><br><span class="line">      <span class="comment"># caServer: https://acme-v02.api.letsencrypt.org/directory # 正式环境的 Let's Encrypt 服务器 (默认)</span></span><br><span class="line">      <span class="attr">caServer:</span> <span class="string">https://acme-staging-v02.api.letsencrypt.org/directory</span> <span class="comment"># 测试环境的 Let's Encrypt 服务器 (用于调试)</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">dnsChallenge:</span></span><br><span class="line">        <span class="attr">provider:</span> <span class="string">cloudflare</span>  <span class="comment"># 使用 DNS服务提供商 code 根据Traefik文档 选择你的服务提供商code 进行 DNS 验证以获取证书</span></span><br><span class="line">        <span class="comment">#disablePropagationCheck: true # (已注释) 如果通过 Cloudflare 获取证书有问题，可以取消注释此行以禁用传播检查</span></span><br><span class="line">        <span class="comment">#delayBeforeCheck: 60s # (已注释) 如果需要确保 TXT 记录准备就绪，可以取消注释此行并设置检查延迟</span></span><br><span class="line">        <span class="attr">resolvers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">"223.5.5.5:53"</span>  <span class="comment"># AliDNS 解析器</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">"119.29.29.29:53"</span>  <span class="comment"># 备用 DNS 解析器</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">"1.1.1.1"</span> <span class="comment"># 备用 DNS 解析器</span></span><br></pre></td></tr></tbody></table></figure><p><code>config.yml</code> 文件，可以选择配置，如果你宿主机有ng反代服务，你使用taerfik 的话会端口冲突，可以配置，但不过要把 <code>docker-compose</code> 和 <code>Traefik</code>的配置文件注释去掉即可：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="comment">#region routers </span></span><br><span class="line">  <span class="attr">routers:</span></span><br><span class="line">    <span class="attr">hexo:</span></span><br><span class="line">      <span class="attr">entryPoints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"https"</span>  <span class="comment"># 指定使用 HTTPS 入口点</span></span><br><span class="line">      <span class="attr">rule:</span> <span class="string">"Host(`hexo.docker.localhost`)"</span>  <span class="comment"># 当访问的主机名为 hexo.local.shellscience.top 时，触发此路由</span></span><br><span class="line">      <span class="attr">middlewares:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">default-headers</span>  <span class="comment"># 应用默认的安全头中间件</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">https-redirectscheme</span>  <span class="comment"># 应用 HTTPS 重定向中间件</span></span><br><span class="line">      <span class="attr">tls:</span> {}  <span class="comment"># 启用 TLS 加密</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">hexo</span>  <span class="comment"># 指定将请求转发到名为 hexo 的服务</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#region services</span></span><br><span class="line">  <span class="attr">services:</span></span><br><span class="line">    <span class="attr">hexo:</span></span><br><span class="line">      <span class="attr">loadBalancer:</span></span><br><span class="line">        <span class="attr">servers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">"http://127.0.0.1:5000"</span>  <span class="comment"># 指定 Hexo 服务的后端服务器 URL</span></span><br><span class="line">        <span class="attr">passHostHeader:</span> <span class="literal">true</span>  <span class="comment"># 传递原始的 Host 头信息到后端服务</span></span><br><span class="line">  <span class="comment">#endregion</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">middlewares:</span></span><br><span class="line">    <span class="attr">https-redirectscheme:</span></span><br><span class="line">      <span class="attr">redirectScheme:</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">https</span>  <span class="comment"># 将 HTTP 请求重定向为 HTTPS</span></span><br><span class="line">        <span class="attr">permanent:</span> <span class="literal">true</span>  <span class="comment"># 使用永久重定向（HTTP 301）</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">default-headers:</span></span><br><span class="line">      <span class="attr">headers:</span></span><br><span class="line">        <span class="attr">frameDeny:</span> <span class="literal">true</span>  <span class="comment"># 禁止网页被嵌入到框架中，防止点击劫持攻击</span></span><br><span class="line">        <span class="attr">browserXssFilter:</span> <span class="literal">true</span>  <span class="comment"># 启用浏览器的 XSS 过滤器，增强安全性</span></span><br><span class="line">        <span class="attr">contentTypeNosniff:</span> <span class="literal">true</span>  <span class="comment"># 防止浏览器 MIME 类型嗅探</span></span><br><span class="line">        <span class="attr">forceSTSHeader:</span> <span class="literal">true</span>  <span class="comment"># 强制启用 HSTS（HTTP 严格传输安全）</span></span><br><span class="line">        <span class="attr">stsIncludeSubdomains:</span> <span class="literal">true</span>  <span class="comment"># HSTS 规则应用于所有子域</span></span><br><span class="line">        <span class="attr">stsPreload:</span> <span class="literal">true</span>  <span class="comment"># 允许将域名加入 HSTS 预加载列表</span></span><br><span class="line">        <span class="attr">stsSeconds:</span> <span class="number">15552000</span>  <span class="comment"># HSTS 头的有效期（秒），这里是 180 天</span></span><br><span class="line">        <span class="attr">customFrameOptionsValue:</span> <span class="string">SAMEORIGIN</span>  <span class="comment"># 允许内容在同源的 iframe 中加载</span></span><br><span class="line">        <span class="attr">customRequestHeaders:</span></span><br><span class="line">          <span class="attr">X-Forwarded-Proto:</span> <span class="string">https</span>  <span class="comment"># 设置 X-Forwarded-Proto 头为 https，用于指示原始请求协议</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">default-whitelist:</span></span><br><span class="line">      <span class="attr">ipAllowList:</span></span><br><span class="line">        <span class="attr">sourceRange:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"10.0.0.0/8"</span>  <span class="comment"># 允许来自 10.0.0.0/8 网段的 IP 地址</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"192.168.0.0/16"</span>  <span class="comment"># 允许来自 192.168.0.0/16 网段的 IP 地址</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"172.16.0.0/12"</span>  <span class="comment"># 允许来自 172.16.0.0/12 网段的 IP 地址</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">secured:</span></span><br><span class="line">      <span class="attr">chain:</span></span><br><span class="line">        <span class="attr">middlewares:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">default-whitelist</span>  <span class="comment"># 应用默认的 IP 白名单中间件</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">default-headers</span>  <span class="comment"># 应用默认的安全头中间件</span></span><br></pre></td></tr></tbody></table></figure><p>配置完毕我们<code>docker-compose up -d</code>如果配置没有问题你就可以通过你配置的域名成功访问<code>Traefik</code>的面板。</p><h1 id="反代代理Dcoekr应用"><a href="#反代代理Dcoekr应用" class="headerlink" title="反代代理Dcoekr应用"></a>反代代理Dcoekr应用</h1><p>这里拿<code>Memos</code>的程序来举例子:</p><p>下面是我的<code>Memos</code>的<code>docker-compose.yaml</code> 文件，我们只需要把暴露的端口删除，添加<code>labels</code>标签以及下面几个配置（你想访问的域名、容器的端口、开启https、使用tls证书）以及让我们的程序接入<code>Traefik</code>的网络就好了。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.0"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">memos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ghcr.io/usememos/memos:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">memos</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/:/var/opt/memos</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">driver=sqlite</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.enable=true"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.memos.rule=Host(`memos.local.com`)"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.services.memos.loadbalancer.server.port=&lt;程序的端口&gt;"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.memos.entrypoints=https"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"traefik.http.routers.memos.tls=true"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">traefik-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">traefik-net:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><code>Traefik</code>DNS服务提供文档：<a href="https://doc.traefik.io/traefik/https/acme/#providers" rel="external nofollow noreferrer">https://doc.traefik.io/traefik/https/acme/#providers</a></p><p><code>Traefik</code>Docker配置文档：<a href="https://doc.traefik.io/traefik/routing/providers/docker/" rel="external nofollow noreferrer">https://doc.traefik.io/traefik/routing/providers/docker/</a></p><h1 id="最后结尾的彩蛋"><a href="#最后结尾的彩蛋" class="headerlink" title="最后结尾的彩蛋"></a>最后结尾的彩蛋</h1><p>找<code>DALL·E</code>生成了两张cover不过总感觉怪怪的，另外一张也放出来吧，有一种土拔鼠变成黄鼠狼的错觉。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/10/05/67011bad7c6dc.webp" alt="DALL·E 2024-10-05 18.57.18 - A professional cover featuring the Traefik logo, which is a Go language gopher mascot directing traffic with a traffic sign. The background shows a gr.webp"></p></body></html>]]></content>
    
    
    <summary type="html">本篇文章详细介绍了如何使用 Traefik 替代繁琐的 Nginx 配置，简化多 Docker 服务的反向代理部署过程。Traefik 具备自动服务发现、自动 SSL 证书续期和反向代理自动配置等优点，尤其适用于本地项目部署。教程包含了使用 Cloudflare 作为 DNS 提供商来申请泛域名 SSL 证书的步骤，同时也涉及反代非 Docker 服务的配置方法。文中还以 Memos 程序为例，展示了如何将其通过 Traefik 进行反向代理。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="2024" scheme="https://blog.ning.moe/tags/2024/"/>
    
    <category term="Docker" scheme="https://blog.ning.moe/tags/Docker/"/>
    
    <category term="Traefik" scheme="https://blog.ning.moe/tags/Traefik/"/>
    
  </entry>
  
  <entry>
    <title>我的网站被人镜像了</title>
    <link href="https://blog.ning.moe/posts/Website-mirrored/"/>
    <id>https://blog.ning.moe/posts/Website-mirrored/</id>
    <published>2024-08-11T13:42:17.000Z</published>
    <updated>2025-01-03T08:41:18.993Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>事情是这样的我昨天配置一些东西是错的，同步上去了今天才发现，随后回滚之后发现防战访问突然下降好多，我以为是Google 没有收录一些文章决定拿一些文章关键词搜一搜，发现了两个我。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/08/11/66b8c1d2bb798.webp" alt="vs.webp"></p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/08/11/66b8c42125db6.webp" alt="mangxb.webp"></p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/08/11/66b8c45dd04f6.webp" alt="Snipaste_2024-08-11_21-42-05.webp"></p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/08/11/66b8c496e4fa7.webp" alt="Snipaste_2024-08-11_21-42-28.webp"><br>我已经向 Google bing dnspod  cloudlfare 进行举报 数字千年版权法案(DMCA) ，请 域名所属人立即删除我所有文章，网站等一些列属于我的数据。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>本篇文章着急发出，可能会有问题，请大家见谅。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;事情是这样的我昨天配置一些东西是错的，同步上去了今天才发现，随后回滚之后发现防战访问突然下</summary>
      
    
    
    
    
    <category term="2024" scheme="https://blog.ning.moe/tags/2024/"/>
    
  </entry>
  
  <entry>
    <title>Authentik OIDC 哪吒面板</title>
    <link href="https://blog.ning.moe/posts/Authentik-NezhaDashboard-OIDC/"/>
    <id>https://blog.ning.moe/posts/Authentik-NezhaDashboard-OIDC/</id>
    <published>2024-08-07T05:05:00.000Z</published>
    <updated>2024-12-31T03:34:09.942Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最开始我的<code>nezha面板</code> 使用的 <code>github</code> 的<code>OAuth 认证</code>的，我的哪吒面板是自动更新到最新版本，最新版本更新好之后我发现无法登录我的<code>nezha 面板</code>了,报错提示是 http: named cookie not present<a href="https://nezha.wiki/guide/loginq.html#http-named-cookie-not-present" rel="external nofollow noreferrer"></a>试了试还是不行，最后看了一下新版本更新日志是改了OIDC不知道是不是这个关系，现在可以自定义oidc提供商了我就改成我自己的<code>Authentik</code> 吧。</p><p>关于我的更多 <a href="/tags/Authentik/"><code>Authentik </code>相关文章</a>  ，详细安装（中文版本）<code>Authentik </code>请访问 <a href="https://www.bilibili.com/video/av1902852247/" rel="external nofollow noreferrer"><strong>ecwuuu</strong>发布的B站视频</a>关于正向代理： <a href="https://roy.wang/authentik-open-source-sso/#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86" rel="external nofollow noreferrer">roywang的文章</a></p><h1 id="准备时间"><a href="#准备时间" class="headerlink" title="准备时间"></a>准备时间</h1><ul><li>本教程适用于官方哪吒面板和<a href="https://github.com/fscarmen2/Argo-Nezha-Service-Container" rel="external nofollow noreferrer">社区F大佬托管第三方服务商</a></li><li>确保你的哪吒面板在 0.18.6 +</li><li>你能在 <code>Authentik</code> 系统中已经配置完毕 哪吒面板</li><li>哪吒面板默认配置在<code>/opt/nezha/dashboard/data/config.yaml</code></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="官方版本"><a href="#官方版本" class="headerlink" title="官方版本"></a>官方版本</h2><blockquote><p>如果您阅读本文是还没有安装哪吒面板的用户，您可以先安装面板，这里不再说明你可以访问 <a href="https://nezha.wiki/guide/dashboard.html" rel="external nofollow noreferrer">官方文档</a> 对于要在安装时填写OIDC 提供商您随便填写后续文章会教您直接修改配置文件。</p></blockquote><p>下面是从官方文档引用的<code>OIDC</code>配置模板</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">oauth2:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">oidc</span>  <span class="comment"># （必填）指定认证类型为 OIDC</span></span><br><span class="line">  <span class="attr">oidcDisplayName:</span> <span class="string">OIDC</span>  <span class="comment"># （可选，默认值为 OIDC）登录页面显示的名称</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">""</span>  <span class="comment"># （至少填写 admin 或 adminGroups 中的一个；默认为空）管理员用户名，用逗号分隔。列在此处的用户被视为管理员</span></span><br><span class="line">  <span class="attr">adminGroups:</span> <span class="string">""</span>  <span class="comment"># （至少填写 admin 或 adminGroups 中的一个；默认为空）管理员组，用逗号分隔。属于这些组的用户被视为管理员。如果不使用组管理，可以省略此项</span></span><br><span class="line">  <span class="attr">clientid:</span> <span class="comment"># （必填）OIDC 客户端 ID</span></span><br><span class="line">  <span class="attr">clientsecret:</span> <span class="comment"># （必填）OIDC 客户端密钥</span></span><br><span class="line">  <span class="attr">oidcIssuer:</span> <span class="string">https://auth.example.com/realms/master</span>  <span class="comment"># （必填）OIDC 提供商的 issuer URL，可以从您的OIDC 提供商处获取</span></span><br><span class="line">  <span class="comment"># oidcLogoutUrl: https://auth.example.com/realms/master/protocol/openid-connect/logout  # （因 bug 目前不能使用）</span></span><br><span class="line">  <span class="comment"># oidcRegisterUrl: # （可选）OIDC 提供商的注册链接</span></span><br><span class="line">  <span class="attr">oidcScopes:</span> <span class="string">openid,profile,email</span>  <span class="comment"># （可选，默认值为 openid,profile,email ）OIDC 请求的 scope，用逗号分隔</span></span><br><span class="line">  <span class="attr">oidcLoginClaim:</span> <span class="string">sub</span>  <span class="comment"># （可选，默认值为 sub）OIDC 返回的用户名字段，可以是 preferred_username、sub 或email</span></span><br><span class="line">  <span class="attr">oidcGroupsClaim:</span> <span class="string">groups</span>  <span class="comment"># （如果使用 adminGroups，则必填，默认值为 groups ）OIDC 返回的用户组信息字段，可以是 groups 或 roles</span></span><br><span class="line">  <span class="attr">oidcAutoCreate:</span> <span class="literal">false</span>  <span class="comment"># （可选，默认值为 false）如果用户不存在，是否自动创建用户</span></span><br><span class="line">  <span class="attr">oidcAutoLogin:</span> <span class="literal">false</span>  <span class="comment"># （可选，默认值为 false）当地址是 /login 时，是否自动跳转到OIDC登录页面</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>官方文档上已经写的比较详细了，但在您需要注意一个问题。</p><p>这里假设您原来使用的<code>GitHub</code>作为提供商 假设您在哪吒面板设置的管理吗名字是 <code>test</code> ，但您Authentik的用户名为 <code>testSSO</code> 这样即使您配置没有问题仍然是登录不上的。</p><p>只要您没有在哪吒数据库里面存储有 您现在 sso 的用户名字符串，您需要吧<code>oidcAutoCreate</code>设置为<code>true</code>。</p><p>然后就是<code>issuer</code>URL，您需要到您的 <code>Authentik</code> 管理员面板，应用程序 —&gt; 提供应用程序—&gt;找到你自己创建的哪吒的服务,点击进去在总览里面找到 <code>OpenID 配置颁发者</code> 这就是<code>issuer</code></p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/08/07/66b2ffcfd08d9.webp" alt="Provider for nezha.webp"></p><p>根据以上我放出我自己的配置</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">oauth2:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">oidc</span>  <span class="comment"># （必填）指定认证类型为 OIDC</span></span><br><span class="line">  <span class="attr">oidcDisplayName:</span> <span class="string">贝壳SSO</span>  <span class="comment"># （可选，默认值为 OIDC）登录页面显示的名称</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">"admin"</span>  <span class="comment"># （至少填写 admin 或 adminGroups 中的一个；默认为空）管理员用户名，用逗号分隔。列在此处的用户被视为管理员</span></span><br><span class="line">  <span class="attr">adminGroups:</span> <span class="string">"authentik Admins"</span>  <span class="comment"># （至少填写 admin 或 adminGroups 中的一个；默认为空）管理员组，用逗号分隔。属于这些组的用户被视为管理员。如果不使用组管理，可以省略此项</span></span><br><span class="line">  <span class="attr">clientid:</span> <span class="string">nezha-123456</span> <span class="comment"># （必填）OIDC 客户端 ID</span></span><br><span class="line">  <span class="attr">clientsecret:</span> <span class="string">passwd</span> <span class="comment"># （必填）OIDC 客户端密钥</span></span><br><span class="line">  <span class="attr">oidcIssuer:</span> <span class="string">https://sso.ning.moe/application/o/nezha-dashboard/</span>  <span class="comment"># （必填）OIDC 提供商的 issuer URL，可以从您的OIDC 提供商处获取</span></span><br><span class="line">  <span class="comment"># oidcLogoutUrl: https://auth.example.com/realms/master/protocol/openid-connect/logout  # （因 bug 目前不能使用）</span></span><br><span class="line">  <span class="comment"># oidcRegisterUrl: # （可选）OIDC 提供商的注册链接</span></span><br><span class="line">  <span class="attr">oidcScopes:</span> <span class="string">openid,profile,email</span>  <span class="comment"># （可选，默认值为 openid,profile,email ）OIDC 请求的 scope，用逗号分隔</span></span><br><span class="line">  <span class="attr">oidcLoginClaim:</span> <span class="string">preferred_username</span>  <span class="comment"># （可选，默认值为 sub）OIDC 返回的用户名字段，可以是 preferred_username</span></span><br><span class="line">  <span class="attr">oidcGroupsClaim:</span> <span class="string">groups</span>  <span class="comment"># （如果使用 adminGroups，则必填，默认值为 groups ）OIDC 返回的用户组信息字段，可以是 groups 或 roles</span></span><br><span class="line">  <span class="attr">oidcAutoCreate:</span> <span class="literal">true</span>  <span class="comment"># （可选，默认值为 false）如果用户不存在，是否自动创建用户</span></span><br><span class="line">  <span class="attr">oidcAutoLogin:</span> <span class="literal">false</span>  <span class="comment"># （可选，默认值为 false）当地址是 /login 时，是否自动跳转到OIDC登录页面</span></span><br></pre></td></tr></tbody></table></figure><p>这里一些例如 <code>adminGroups</code>  <code>oidcGroupsClaim</code>如果您和我不对，你可以在刚才的 <code>Authentik</code> 里面有个<code>预览</code>选择你或者你的用户拿到一些<code>json</code>的信息，这可能会帮助你更好的找到你需要填写那些值。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/08/07/66b2ffda1767d.webp" alt="Provider for nezha JWT.webp"></p><h2 id="F大佬的-Argo-Nezha-Service-Container"><a href="#F大佬的-Argo-Nezha-Service-Container" class="headerlink" title="F大佬的 Argo-Nezha-Service-Container"></a>F大佬的 Argo-Nezha-Service-Container</h2><p>用F大佬项目看上面的流程应该已经可以配置了，但是我在使用的时候发现可能，你在docker 启动的参数用还是随便乱填写 <code>GH_CLIENTID</code> 和 <code>GH_CLIENTSECRET</code> 可能会有问题（会启动之后有概率覆盖<code>config.yaml</code> 配置文件的这两个值数据），推荐还是填写您在 <code>Authentik</code> 上配置的 <code>id</code> 和<code>Secret</code>。</p><p>还是一样你可以选择在容器里面编辑或者到处文件以及你也可以在你GitHub备份的文件中修改在推上去。</p><p>[config.yaml 的配置](## 官方版本)看上面配置就可以了，如果测试没有问题记得在在容器里面运行<code>./backup.sh</code> 再次备份一下。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>哪吒面板官方文档：<a href="https://nezha.wiki/" rel="external nofollow noreferrer">https://nezha.wiki/</a></li><li>Argo-Nezha-Service-Container 项目的README 文件：<a href="https://github.com/fscarmen2/Argo-Nezha-Service-Container" rel="external nofollow noreferrer">https://github.com/fscarmen2/Argo-Nezha-Service-Container</a></li></ul></body></html>]]></content>
    
    
    <summary type="html">这篇文章详细介绍了如何将 Nezha 面板的 OIDC 认证从 GitHub OAuth 切换到 Authentik，以解决版本更新后的登录问题。内容包括准备步骤、官方版本及 Argo-Nezha-Service-Container 版本的具体配置方法，提供详细的配置模板和实际示例。帮助用户正确设置 OIDC 参数，实现与 Authentik 的无缝集成，从而确保 Nezha 面板的正常运行。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="2024" scheme="https://blog.ning.moe/tags/2024/"/>
    
    <category term="Authentik" scheme="https://blog.ning.moe/tags/Authentik/"/>
    
    <category term="SSO" scheme="https://blog.ning.moe/tags/SSO/"/>
    
    <category term="OIDC" scheme="https://blog.ning.moe/tags/OIDC/"/>
    
    <category term="OAuth2" scheme="https://blog.ning.moe/tags/OAuth2/"/>
    
    <category term="nezha" scheme="https://blog.ning.moe/tags/nezha/"/>
    
  </entry>
  
  <entry>
    <title>Gitea SSO 登录优化与自动注册设置</title>
    <link href="https://blog.ning.moe/posts/Authentik-Gitea-SSO/"/>
    <id>https://blog.ning.moe/posts/Authentik-Gitea-SSO/</id>
    <published>2024-08-04T00:50:37.000Z</published>
    <updated>2024-12-31T03:34:05.274Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>gitea 的SSO登录逻辑，是通过OIDC 登录完毕和已经gitea自己的账户进行绑定，如果 没有账户gitea 会要求你注册一个再绑定，但是gitea 并没有能设置通过sso 进来的没有注册的用户开发注册，只有要么所有人都可以注册要么不可以注册。嗯。。。。感觉怪怪的。</p><p>并且更改配置文件还需要手动重启容器，不可能我认识人都创建好gitea吧，或者不能每次他们第一次要用gitea 我需要配置打开注册。</p><p>关于我的更多 <a href="/tags/Authentik/"><code>Authentik </code>相关文章</a>  ，详细安装（中文版本）<code>Authentik </code>请访问 <a href="https://www.bilibili.com/video/av1902852247/" rel="external nofollow noreferrer"><strong>ecwuuu</strong>发布的B站视频</a>关于正向代理： <a href="https://roy.wang/authentik-open-source-sso/#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86" rel="external nofollow noreferrer">roywang的文章</a></p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p><strong>此教程默认情况下视为你已经配置好了gitea 的OIDC登录。</strong></p><p>如果您没有实现配置好，可以看 ecwuuuuu 的 <a href="https://www.bilibili.com/video/av1952943836/" rel="external nofollow noreferrer">你可以观看 将应用接入统一登陆 - OAuth 协议篇 - 以 Gitea 和 Grafana 为例</a></p><p>本文章配合 <a href="/posts/CloudFlare-Tunnel-Application-Access/">使用 Cloud Flare Tunnel 和 Acces Application 安全的暴露在公网</a> 进行使用，使用 CloudFlare 的Zero Trust进行<code>转发验证</code></p><p>如果你需要使用nginx配置转发验证，可以看 ecwuuuuu 的 <a href="https://ecwuuuuu.com/post/authentik-tutorial-4-setup-forwardauth/" rel="external nofollow noreferrer">通过反向代理和 ForwardAuth 接入任何应用</a>或者访问他的B站视频 <a href="https://www.bilibili.com/video/av1803923865/" rel="external nofollow noreferrer">配置 ForwardAuth 将任意应用加入统一登陆</a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>请确保你的gitea 配置文件和我下面提供的一样（配置文件一般在<code>&lt;宿主机容器映射&gt;/data/gitea/conf/app.ini</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[openid]</span><br><span class="line">ENABLE_OPENID_SIGNIN = true</span><br><span class="line">ENABLE_OPENID_SIGNUP = true</span><br><span class="line"></span><br><span class="line">[service]</span><br><span class="line">DISABLE_REGISTRATION = false</span><br><span class="line">REQUIRE_SIGNIN_VIEW = true</span><br><span class="line">REGISTER_EMAIL_CONFIRM = false</span><br><span class="line">ENABLE_NOTIFY_MAIL = true</span><br><span class="line">ALLOW_ONLY_EXTERNAL_REGISTRATION = false</span><br><span class="line">ENABLE_CAPTCHA = false</span><br><span class="line">DEFAULT_KEEP_EMAIL_PRIVATE = true</span><br><span class="line">DEFAULT_ALLOW_CREATE_ORGANIZATION = true</span><br><span class="line">DEFAULT_ENABLE_TIMETRACKING = true</span><br><span class="line">NO_REPLY_ADDRESS = noreply.localhost</span><br></pre></td></tr></tbody></table></figure><p>屏蔽注册页面 <code>user/sign_up</code></p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/08/04/66aed81093245.webp" alt="CloudFlare-Zero Trust-Gitea-Sign_up.webp"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>将应用接入统一登陆 - OAuth 协议篇 - 以 Gitea 和 Grafana 为例:<a href="https://www.bilibili.com/video/av1952943836/" rel="external nofollow noreferrer">https://www.bilibili.com/video/av1952943836/</a></p><p>通过反向代理和 ForwardAuth 接入任何应用:<a href="https://ecwuuuuu.com/post/authentik-tutorial-4-setup-forwardauth/" rel="external nofollow noreferrer">https://ecwuuuuu.com/post/authentik-tutorial-4-setup-forwardauth/</a></p><p>使用 Cloud Flare Tunnel 和 Acces Application 安全的暴露在公网:<a href="https://blog.ning.moe/posts/CloudFlare-Tunnel-Application-Access/">https://blog.ning.moe/posts/CloudFlare-Tunnel-Application-Access/</a></p></body></html>]]></content>
    
    
    <summary type="html">本文介绍了如何优化 Gitea 的 SSO 登录逻辑，解决注册和配置上的问题。通过配置 Gitea 的 OIDC 登录并结合 CloudFlare Zero Trust 进行转发验证，用户可以在确保安全的情况下使用 Gitea 的 SSO 功能。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="2024" scheme="https://blog.ning.moe/tags/2024/"/>
    
    <category term="Authentik" scheme="https://blog.ning.moe/tags/Authentik/"/>
    
    <category term="Gitea" scheme="https://blog.ning.moe/tags/Gitea/"/>
    
    <category term="SSO" scheme="https://blog.ning.moe/tags/SSO/"/>
    
    <category term="OIDC" scheme="https://blog.ning.moe/tags/OIDC/"/>
    
    <category term="OAuth2" scheme="https://blog.ning.moe/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>自建属于自己的递归DNS</title>
    <link href="https://blog.ning.moe/posts/Create-Recursive-DNS/"/>
    <id>https://blog.ning.moe/posts/Create-Recursive-DNS/</id>
    <published>2024-07-20T14:10:09.000Z</published>
    <updated>2024-12-31T03:34:49.628Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>截至发稿前阿里<code>DNS</code> 也宣布了对公共<code>DNS</code>进行限速了，其实在出这篇文章之前阿里<code>DNS</code>并没有限速，这里只是顺带提一嘴，想说的是，江苏地区使用阿里<code>DNS</code>解析会出现污染情况，先上两张图，来源<code>Adguard Home</code>日志和<code>itdog</code> 测试，<code>Adguard Home</code>使用的还是<code>dot</code>进行连接，也就是说不会在数据传输中被篡改。</p><table><thead><tr><th><img src="https://img.misaka.pics/ShellBlogImg/1/2024/07/20/669bc956e1a64.webp" alt="adguard-gome-dns-log.webp" title="adguard-gome-dns-log.webp"></th><th><img src="https://img.misaka.pics/ShellBlogImg/1/2024/07/20/669bc92cee346.webp" alt="itdog-dns-log.webp" title="itdog-dns-log.webp"></th></tr></thead></table><p>在看看其他的dns.</p><table><thead><tr><th><img src="https://img.misaka.pics/ShellBlogImg/1/2024/07/20/669bdc6578294.webp" alt="dns-119.29.29.29.webp" title="dns-119.29.29.29.webp"></th><th><img src="https://img.misaka.pics/ShellBlogImg/1/2024/07/20/669bdc646c07f.webp" alt="dns-114.114.114.webp" title="dns-114.114.114.webp"></th></tr></thead><tbody><tr><td><img src="https://img.misaka.pics/ShellBlogImg/1/2024/07/20/669bdc640dd71.webp" alt="dns-1.1.1.1.webp" title="dns-1.1.1.1.webp"></td><td></td></tr></tbody></table><p><code>Adgurad Home</code> 虽然很好用，但也是请求上游的递归<code>DNS</code>服务器，严格来说并不是一个递归<code>DNS</code>，现在上游也已经遭受污染，是时候只能选择自建递归<code>DNS</code>了，从根查起减少被污染的概率，同时使用<code>dnscrypt</code>来进行解析国外域名，<code>mosdns</code> 负责进行代理<code>DNS</code>规则，<code>unbound </code>负责进行递归<code>DNS</code>，感觉是不是已经脑袋抓狂了，需要配置这么多服务，别怕,感谢 <a href="https://github.com/kkkgo/PaoPaoDNS" rel="external nofollow noreferrer">kkkgo大佬打包好的项目PaoPaoDNS</a>。</p><p>这里会有人想，从根开始查起延迟不会很高吗？这里放上我<code>Adguard Home</code>指向我在本地自建的递归<code>dns</code>的日志。<br><img src="https://img.misaka.pics/ShellBlogImg/1/2024/07/20/669bcf912251b.webp" alt="adgurad-36ms.webp"></p><h1 id="PaoPaoDns工作流程"><a href="#PaoPaoDns工作流程" class="headerlink" title="PaoPaoDns工作流程"></a>PaoPaoDns工作流程</h1><p>可能这里又说的不对的地方，欢迎在评论指出。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/07/20/669bdd0462122.webp" alt="PaoPaoDNS-workflow.webp"></p><h1 id="搭建前的准备"><a href="#搭建前的准备" class="headerlink" title="搭建前的准备"></a>搭建前的准备</h1><p>需要准备一个<code>x86</code>小主机，能跑<code>docker </code>就好了，内存至少有<code>512mb</code> 可用的内存。</p><p>对于最近docker hub 连接不上的，可以试试 <a href="https://docker.lmirror.top/" rel="external nofollow noreferrer">栗子的docker hub 代理</a>。</p><h1 id="搭建开始"><a href="#搭建开始" class="headerlink" title="搭建开始"></a>搭建开始</h1><p>我这里放上我自己的docker-compose 配置。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">paopaodns:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">sliamb/paopaodns:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">paopaodns</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&lt;宿主机地址&gt;/mydata:/data</span>    <span class="comment"># 将数据挂载到容器内部的 /data 目录</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">CNAUTO:</span> <span class="string">"yes"</span>           <span class="comment"># 是否CN规则分流（可选值: yes, no）</span></span><br><span class="line">      <span class="attr">DNSPORT:</span> <span class="string">"53"</span>           <span class="comment"># DNS 服务端口号</span></span><br><span class="line">      <span class="attr">DNS_SERVERNAME:</span> <span class="string">"ShellDns.ning.moe"</span>  <span class="comment"># DNS 服务器名称（不含空格的英文字符串）</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">"Asia/Shanghai"</span>     <span class="comment"># 时区设置</span></span><br><span class="line">      <span class="attr">UPDATE:</span> <span class="string">"weekly"</span>        <span class="comment"># 更新IP、域名库的频率（可选值: no, daily, weekly, monthly）</span></span><br><span class="line">      <span class="attr">IPV6:</span> <span class="string">"raw"</span>              <span class="comment"># 是否启用 IPv6（可选值: no, yes, only6, yes_only6, raw）</span></span><br><span class="line">      <span class="attr">CNFALL:</span> <span class="string">"yes"</span>           <span class="comment"># 是否包含中国大陆列表（可选值: no, yes）</span></span><br><span class="line">      <span class="attr">EXPIRED_FLUSH:</span> <span class="string">"yes"</span>    <span class="comment"># 是否自动清理过期缓存（可选值: no, yes）</span></span><br><span class="line">      <span class="attr">CUSTOM_FORWARD_TTL:</span> <span class="string">"0"</span> <span class="comment"># 自定义转发 TTL</span></span><br><span class="line">      <span class="attr">ADDINFO:</span> <span class="string">"yes"</span>          <span class="comment"># 在DNS查询结果中增加ADDITIONAL SECTION的调试信息，如结果来源、查询延迟、失败原因等，使用dig命令就可以实时追踪域名结果来源</span></span><br><span class="line">      <span class="attr">USE_MARK_DATA:</span> <span class="string">"yes"</span>    <span class="comment"># 全球百万域名库，在判断大陆分流的时候优先使用该数据.</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"5533:53/tcp"</span>           <span class="comment"># 对外开放 TCP 53 端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"5533:53/udp"</span>           <span class="comment"># 对外开放 UDP 53 端口</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="number">1.</span><span class="string">5G</span><span class="comment">#限制容器内存</span></span><br></pre></td></tr></tbody></table></figure><p>需要了解其他配置信息看看GitHub的文档：<a href="https://github.com/kkkgo/PaoPaoDNS?tab=readme-ov-file#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E" rel="external nofollow noreferrer">https://github.com/kkkgo/PaoPaoDNS?tab=readme-ov-file#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E</a></p><p>验证你的递归DNS正常运行，执行以下命令：</p><figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -<span class="built_in">type</span>=TXT whoami.ds.akahelp.<span class="built_in">net</span> &lt;PaoPaoDnsIp&gt;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Server:  <span class="title">ShellDns.ning.moe</span></span></span><br><span class="line"><span class="function"><span class="title">Address</span>:  10.0.0.3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Non</span>-<span class="title">authoritative</span> <span class="title">answer</span>:</span></span><br><span class="line"><span class="function"><span class="title">whoami.ds.akahelp.net</span>   <span class="title">text</span> =</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        "<span class="title">ns</span>"</span></span><br><span class="line"><span class="function">        "1.1.1.1"  #如果这里是你的出口<span class="title">ip</span> 就代表<span class="title">paopaodns</span> 正常工作了</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>引用文档：</p></blockquote><p>验证你的递归DNS正常运行，可以执行以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器内置执行 test.sh</span></span><br><span class="line">docker <span class="built_in">exec</span> paopaodns test.sh</span><br><span class="line"><span class="comment"># 如果执行后输出 ALL TEST PASS，则所有组件都工作正常。</span></span><br><span class="line"><span class="comment"># 如果显示 FAIL，可以执行 debug.sh 进一步分析原因。</span></span><br></pre></td></tr></tbody></table></figure><p>同时你可以查阅<a href="https://github.com/kkkgo/PaoPaoDNS/discussions/categories/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97" rel="external nofollow noreferrer">更新日志</a>的最新版本公告时间，检查输出的镜像版本时间是否大于等于当前最新版本。<br>需要注意的是，如果你的网络有“自动分流<code>IP</code>”的功能，请把容器的IP加入不分流的名单，因为权威<code>DNS</code>需要准确的IP去判断，<code>IP</code>分流会影响权威<code>DNS</code>的判断。此外，一些软路由存在劫持<code>DNS</code>请求的情况，解决办法参见<a href="https://github.com/kkkgo/PaoPaoDNS/issues/2#issuecomment-1504708367" rel="external nofollow noreferrer">这个issue</a>。<br><em><strong>[DNS hijack]DNS劫持算是经常问的高频问题了，<a href="https://github.com/kkkgo/PaoPaoDNS/discussions/111#discussioncomment-8872824" rel="external nofollow noreferrer">请参考</a></strong></em></p><h1 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h1><p>PaoPaoDns项目&amp;文档：<a href="https://github.com/kkkgo/PaoPaoDNS" rel="external nofollow noreferrer">https://github.com/kkkgo/PaoPaoDNS</a></p><p>栗次元镜像世界-Docker加速源：<a href="https://www.lmirror.top/docker.html" rel="external nofollow noreferrer">https://www.lmirror.top/docker.html</a></p></body></html>]]></content>
    
    
    <summary type="html">本文详细介绍了如何自建递归DNS，通过结合Adguard Home、unbound、dnscrypt和mosdns等工具，实现更安全、更高效的DNS解析，减少污染和限速问题，并提供了详细的配置步骤和示例。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="2024" scheme="https://blog.ning.moe/tags/2024/"/>
    
    <category term="DNS" scheme="https://blog.ning.moe/tags/DNS/"/>
    
    <category term="Adguard Home" scheme="https://blog.ning.moe/tags/Adguard-Home/"/>
    
    <category term="Root Servers" scheme="https://blog.ning.moe/tags/Root-Servers/"/>
    
    <category term="网络安全" scheme="https://blog.ning.moe/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="unbound" scheme="https://blog.ning.moe/tags/unbound/"/>
    
    <category term="dnscrypt" scheme="https://blog.ning.moe/tags/dnscrypt/"/>
    
    <category term="mosdns" scheme="https://blog.ning.moe/tags/mosdns/"/>
    
  </entry>
  
  <entry>
    <title>Umami空白页面</title>
    <link href="https://blog.ning.moe/posts/fix-umami-blank-page/"/>
    <id>https://blog.ning.moe/posts/fix-umami-blank-page/</id>
    <published>2024-06-27T11:37:05.000Z</published>
    <updated>2024-12-31T03:34:58.276Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每天会去umami 后台看一下当天的访客以及访问量那些文章，然后就发现了打开website的时候是空白页面，我以为是umami 没有更新最新版导致的问题，等我更新完毕之后发现还是一样的，打开 f12 看了一下 <code>webpack-532820dc741ca459.js</code>文件一直404。顺手水一下吧。<br><img src="https://img.misaka.pics/ShellBlogImg/1/2024/06/27/667d517263cb3.webp" alt="umami-blank-page.webp"></p><p>环境说明：</p><ul><li>docker-compose 部署的umami版本是 v2.12.1</li><li>宝塔nginx 反代的</li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>请检查反代 是否为<code>proxy_pass http://127.0.0.1:&lt;端口&gt;;</code> 不能是<code>proxy_pass http://127.0.0.1:&lt;端口&gt;/;</code></p><p>如果不行请尝试删除反代重新添加，以及清理cdn的缓存。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/06/27/667d52e17d423.webp" alt="umami-blank-page-2.webp"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>Umami 的GitHub issues ：<a href="https://github.com/umami-software/umami/issues/2269" rel="external nofollow noreferrer">https://github.com/umami-software/umami/issues/2269</a></p></body></html>]]></content>
    
    
    <summary type="html">本文介绍了使用 Umami 网站统计工具时遇到空白页面的问题，并分享了通过检查反向代理配置和清理 CDN 缓存解决该问题的方法。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="2024" scheme="https://blog.ning.moe/tags/2024/"/>
    
    <category term="Umami" scheme="https://blog.ning.moe/tags/Umami/"/>
    
    <category term="PV" scheme="https://blog.ning.moe/tags/PV/"/>
    
    <category term="网站统计，UV" scheme="https://blog.ning.moe/tags/%E7%BD%91%E7%AB%99%E7%BB%9F%E8%AE%A1%EF%BC%8CUV/"/>
    
    <category term="Ip" scheme="https://blog.ning.moe/tags/Ip/"/>
    
  </entry>
  
  <entry>
    <title>使用Cloud Flare Tunnel和 Acces Application安全的暴露在公网</title>
    <link href="https://blog.ning.moe/posts/CloudFlare-Tunnel-Application-Access/"/>
    <id>https://blog.ning.moe/posts/CloudFlare-Tunnel-Application-Access/</id>
    <published>2024-04-23T01:43:40.000Z</published>
    <updated>2024-12-31T03:35:26.396Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>如果搞 Home Lab 始终绕不开的话题是，我们如何将自己的内网服务暴露到公网上，又如何保证我们的安全。<br>现在可以使用我们赛博菩萨 Cloudflare 提供的 Zero Trust 来保护我们的安全。</p><p>演示的dome ： <a href="https://hp.ning.moe/" rel="external nofollow noreferrer">HomePage</a> 和 <a href="https://misakashell.cloudflareaccess.com/" rel="external nofollow noreferrer">Cloud Flare Zero Trust 主页</a></p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><h2 id="使用-Tunnel-暴露服务"><a href="#使用-Tunnel-暴露服务" class="headerlink" title="使用 Tunnel 暴露服务"></a>使用 Tunnel 暴露服务</h2><p>我们需要先登录<a href="https://one.dash.cloudflare.com/" rel="external nofollow noreferrer">CF zero trust的管理平台</a>，添加新的隧道点击：<code>Networks/Tunnels</code> 我们需要添加一个隧道让我们本地和 <code>Cloudflare Zero Trust</code>服务器进行连接。简单的配置完隧道名字</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/22/6626359570249.webp" alt="Cloud-Flare-Zero-Trust-Dash-Tunnels.webp"></p><p>会自动跳转到tunnel 这个页面，没跳转的 Networks/Tunnels/你的隧道/config。我们需要安装一个cloudflared的程序，这个页面已经为我们提供好了常见的系统，如Linux MacOS Windows，复制命令直接在我们终端运行即可。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/22/66263669cc5c3.webp" alt="CloudFlared-Download.webp"></p><p>然后 下一步 ，简单配置一下。保存即可。返回菜单会发现刚刚创建的 <code>Tunnel</code> 等待 <code>Status</code> 显示<code>HEALTHY</code> 访问你的 配置好的域名应该就可以访问了。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/22/6626371255c1f.webp" alt="Cloud-Flare-Tunnel-Config.webp"></p><h2 id="使用-Access-Applications-认证"><a href="#使用-Access-Applications-认证" class="headerlink" title="使用 Access Applications 认证"></a>使用 Access Applications 认证</h2><p>首先你需要确保你有登录方式 <code>Settings</code> –&gt;<code>Authentication</code>–&gt;<code>Login methods</code> ,如果没有你需要自行创建。</p><p>来到<code> Access</code> –&gt;<code> Applications</code> –&gt; <code> Add an application</code> 选择<code>Self-hosted</code>，填写你刚才的域名，然后下一步。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/22/66263cfec6386.webp" alt="CF-Access-Applications.webp"></p><p><code>policy name</code> 可以随便填写 记得 <code>Action</code>是 <code>Allow</code>，这里的Session 是多久在进行登录验证，可以调节时间长一点。</p><p><code>Create additional rules</code> 根据你刚才配置的 <code>Authentication</code> 来填写，我这里是填写CF自带的邮箱验证码进行登录的。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/22/66263cff40b37.webp" alt="CF-Add an application.webp"></p><p>配置完毕之后，访问你配置的域名就会出现拦截了，例如我<a href="https://hp.ning.moe/" rel="external nofollow noreferrer">配置好的</a>这我设置了自动跳转所以会到我的<code>SSO.ning.moe</code></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/" rel="external nofollow noreferrer">Cloudflare Tunnel 配置文档</a></p><p><a href="https://developers.cloudflare.com/cloudflare-one/applications/" rel="external nofollow noreferrer">Applications Access</a></p></body></html>]]></content>
    
    
    <summary type="html">利用 Cloudflare 提供的 Zero Trust 解决方案，将内网服务安全地暴露到公网的方法。通过配置 Tunnel 和 Access Applications，我们可以轻松实现安全连接和认证，确保数据传输和访问的安全性。这一方案简单易用，为 Home Lab 的搭建提供了可靠的安全保障。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="2024" scheme="https://blog.ning.moe/tags/2024/"/>
    
    <category term="CloudFlare" scheme="https://blog.ning.moe/tags/CloudFlare/"/>
    
    <category term="Zero Trust" scheme="https://blog.ning.moe/tags/Zero-Trust/"/>
    
  </entry>
  
  <entry>
    <title>Memos 对接 Authentik</title>
    <link href="https://blog.ning.moe/posts/authentik-OAuth2-memos/"/>
    <id>https://blog.ning.moe/posts/authentik-OAuth2-memos/</id>
    <published>2024-04-09T14:40:34.000Z</published>
    <updated>2024-12-31T03:34:14.755Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于我的更多 <a href="/tags/Authentik/"><code>Authentik </code>相关文章</a>  ，详细安装（中文版本）<code>Authentik </code>请访问 <a href="https://www.bilibili.com/video/av1902852247/" rel="external nofollow noreferrer"><strong>ecwuuu</strong>发布的B站视频</a>关于正向代理： <a href="https://roy.wang/authentik-open-source-sso/#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86" rel="external nofollow noreferrer">roywang的文章</a></p><blockquote><p> 配置中：这是什么啊，这么麻烦还没过去啊。 配置后：真香好方便。</p></blockquote><p>使用本文前请自行在 <code>Authentik </code>配置好 Memos使用的<code>应用程序</code>和<code>提供程序</code></p><h1 id="Authentik-配置"><a href="#Authentik-配置" class="headerlink" title="Authentik 配置"></a>Authentik 配置</h1><p>默认你已经创建好了，一个给Memos使用的<code>应用程序</code>和<code>提供程序</code>,我们需要更改<code>提供程序</code>(给Memos 的)我们点击编辑</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/09/66155d6445bbc.webp" alt="Authentik 配置 Memos-1.webp"></p><blockquote><p>选择客户端可以使用哪些作用域。客户端仍然需要指定访问数据的范围。</p><p>按住 <code>ctrl/command</code> 键可选择多个项目。</p></blockquote><p>我们选中<code>authentik default OAuth Mapping: OpenID email</code> 和 <code>authentik default OAuth Mapping: OpenID openid</code>将<code>Subject 模式</code>改成基于用户名，然后更新。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/09/6615597f90737.webp" alt="Authentik 配置 Memos.webp"></p><h1 id="Memos配置"><a href="#Memos配置" class="headerlink" title="Memos配置"></a>Memos配置</h1><blockquote><p>在截至发文时 <code>Memos</code> 的版本为<code>v0.20.1</code>版本，<code>Memos</code>通过用户名为主键，其实只需要给<code>username</code>字段即可。</p></blockquote><p>根据上文调整的，现在sub 是我们的用户名字段，按照文章截屏填写其他的自行替换。这样你的的<code>Memos</code>就可以使用<code>Authentik</code>进行登录了。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/09/66155e6ca6dc7.webp" alt="Memos-Oauth2-config.webp"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><code>Memos</code>的文档：<a href="https://www.usememos.com/docs/advanced-settings/keycloak" rel="external nofollow noreferrer">https://www.usememos.com/docs/advanced-settings/keycloak</a></p></body></html>]]></content>
    
    
    <summary type="html">Authentik uses OAuth2 to interface with Memos. Authentik 使用 OAuth2 对接 Memos</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="2024" scheme="https://blog.ning.moe/tags/2024/"/>
    
    <category term="Authentik" scheme="https://blog.ning.moe/tags/Authentik/"/>
    
    <category term="SSO" scheme="https://blog.ning.moe/tags/SSO/"/>
    
    <category term="OIDC" scheme="https://blog.ning.moe/tags/OIDC/"/>
    
    <category term="OAuth2" scheme="https://blog.ning.moe/tags/OAuth2/"/>
    
    <category term="Memos" scheme="https://blog.ning.moe/tags/Memos/"/>
    
  </entry>
  
  <entry>
    <title>爱快IPv6防火墙配置</title>
    <link href="https://blog.ning.moe/posts/Ikuai-firewall-IPv6/"/>
    <id>https://blog.ning.moe/posts/Ikuai-firewall-IPv6/</id>
    <published>2024-03-01T15:59:59.000Z</published>
    <updated>2024-12-31T03:35:05.339Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>爱快尽然默认没有开启<code>IPv6</code>对内网设备的阻断，我发现的时候十分震惊，而且已经在公网上暴露有一天以上了，最糟糕的事情，内网设备的密码全部是弱密码，吓得我先立刻断掉<code>IPv6</code>接入，仔细排查了一下内网设备还好没有人扫到并且进行爆破。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>请确保你的<code>ikuai </code>系统是最新版本并且登录<code>ikuai Web</code>后台，<code>安全设置</code> –&gt;<code>ACL规则</code></p><h2 id="阻断所有IPv6链接"><a href="#阻断所有IPv6链接" class="headerlink" title="阻断所有IPv6链接"></a>阻断所有IPv6链接</h2><blockquote><p>此操作不会阻断响应<code>IPv6</code>的流量</p></blockquote><p>由于 <code>ikuai </code>在 3.7.11 版本还不支持放行或阻断<code> ICMP</code> 协议，如果您想外网设备能ping通内网的话，需要需要创建两个配置，一个是阻断<code>TCP</code>还有一个阻断<code>UDP</code>，不想<code>ping</code>通的话，只需要创建一个配置选择任意协议即可。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/03/06/65e834d3a0bdd.webp" alt="ipv6防护墙介绍.webp"></p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/03/06/65e834d40ca02.webp" alt="ipv6阻断.webp"></p><p>进接口一定是<code>wan</code>口由于笔者只有一个<code>wan</code>口，如果您有多个话请务必全部勾选，出接口是<code>lan</code>同样如果您有多个<code>lan</code>接口请全部勾上，这样我们内网设备就不会暴露外网了。</p><h2 id="打开指定IPv6的连接"><a href="#打开指定IPv6的连接" class="headerlink" title="打开指定IPv6的连接"></a>打开指定IPv6的连接</h2><blockquote><p>再说指定放行<code>IPv6</code>地址，如果您是静态<code>IPv6</code>，那你自己放行那个ip 即可，但是身为家庭宽带的话都是动态<code>IPv6</code>地址根本不可能知道ip会变成什么样子，还是说每次变化ip 的地址重新改吗？这里需要了解一下ipv6 的后缀生成是受MAC 地址影响的，通过EUI-64 编码进行处理，详情访问: <a href="https://ccie.lol/knowledge-base/ipv6-use-eui-64-convert-link-local-address/" rel="external nofollow noreferrer">【转】通过EUI-64自动生成IPv6地址和IPv6链路本地地址（Link-Local Address）</a></p></blockquote><p><strong>对于windows 获取ipv6地址使用 EUI-64 编码得到的理论值和实际值可能不一样</strong></p><p>可以使用 <a href="https://eui64-calc.princelle.org/" rel="external nofollow noreferrer">EUI-64 计算器</a></p><p>例如 <code>bc:34:11:c6:8a:19 </code>通过计算可以得到 <code>BE34:11FF:FEC6:8A19</code> 理论情况的<code>ipv6</code>，据我测试后四位基本上都是一样的，前面受到<code>IPv6</code>前缀影响。</p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/03/06/65e846c30a412.webp" alt="指定IPv6放行.webp" style="zoom:67%;"><p>在已经匹配的内容中<code>::8A19</code>改成你自己的后缀四位，<code>ikuai </code>的防火墙逻辑是先放行后阻断，所以不需要关系防火墙配置的顺序。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::8a1f/::ffff</span><br></pre></td></tr></tbody></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://ccie.lol/knowledge-base/ipv6-use-eui-64-convert-link-local-address/" rel="external nofollow noreferrer">【转】通过EUI-64自动生成IPv6地址和IPv6链路本地地址（Link-Local Address）</a></p><p> <a href="https://eui64-calc.princelle.org/" rel="external nofollow noreferrer">EUI-64 计算器</a></p></body></html>]]></content>
    
    
    <summary type="html">这篇介绍了如何在爱快系统中配置IPv6防火墙。作者指出系统默认未开启IPv6阻断，存在安全隐患，提供了阻断和放行IPv6连接的配置方法，同时解释了EUI-64编码生成IPv6地址的过程。适用于爱快系统用户保护内网设备安全。</summary>
    
    
    
    
    <category term="2024" scheme="https://blog.ning.moe/tags/2024/"/>
    
    <category term="防火墙" scheme="https://blog.ning.moe/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
    <category term="firewall" scheme="https://blog.ning.moe/tags/firewall/"/>
    
    <category term="Ikuai" scheme="https://blog.ning.moe/tags/Ikuai/"/>
    
    <category term="IPv6" scheme="https://blog.ning.moe/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>改造家里网络</title>
    <link href="https://blog.ning.moe/posts/Home-NetWork/"/>
    <id>https://blog.ning.moe/posts/Home-NetWork/</id>
    <published>2024-02-08T03:13:49.000Z</published>
    <updated>2024-03-12T16:32:13.689Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>也好久没更新来水一波。</p></blockquote><p>寒假里面，打算在折腾一下家里面的网络，将家里21年买的<code>r2s</code>换成<code>J4125</code>这下就够我折腾的了。</p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/03/06/65e8108d61fe7.webp" alt="网络拓补图.webp" style="zoom:50%;"><p>这是我目前的家里主题结构 由<code>r2s</code>软路由担任<code>PPPOE</code>拨号，有两个<code>AP</code> 组成有线<code>mesh</code>。</p><p>对于 <code>J4125 </code>我打算使用<code>PVE</code>+<code>Ikuai</code>+<code>Debian</code></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="折腾前的痛点"><a href="#折腾前的痛点" class="headerlink" title="折腾前的痛点"></a>折腾前的痛点</h2><ul><li>稳定：对于<code>r2s</code>来说有时候不是特别问题定，需要定时重启，我尝试换了很多的固件，都无法解决此问题</li><li>性能不足 ：<code>r2s</code>有人测试基本上稳定千兆是没有问题的了（在不使用科学上网的时候），但对于小包转发来说多少有些吃力。</li><li>ARM 生态问题：我知道ARM 发展的很好，但很多老的程序还只能支持<code>X86</code>.</li></ul><h2 id="折腾解决之后的"><a href="#折腾解决之后的" class="headerlink" title="折腾解决之后的"></a>折腾解决之后的</h2><ul><li>稳定：目前连续运行了20天没有发现异常</li><li>性能：<code>J4125</code>妥妥够我300mbps 的带宽使用了（满载带宽，CPU占用15%~20%）</li><li>软件：解决了ARM 部分软件问题。</li></ul><p><code>J4125</code>进行<code>PVE </code>虚拟化，由<code>Ikuai </code>作为主路由进行<code>PPPOE</code> 以及流控管理，<code>Debian`` docker</code> 化跑<code>Adguard Heome </code>家用<code>DNS </code>。</p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/03/06/65e82e1b241e5.webp" alt="网络拓补图-2.webp" style="zoom: 67%;"></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;也好久没更新来水一波。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p</summary>
      
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Ikuai" scheme="https://blog.ning.moe/tags/Ikuai/"/>
    
    <category term="J4125" scheme="https://blog.ning.moe/tags/J4125/"/>
    
  </entry>
  
  <entry>
    <title>2023 总结</title>
    <link href="https://blog.ning.moe/posts/2023-Annual-Summary/"/>
    <id>https://blog.ning.moe/posts/2023-Annual-Summary/</id>
    <published>2023-12-31T15:59:59.000Z</published>
    <updated>2024-11-02T08:26:03.593Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><blockquote><p>应该这个文章会在 31/12/2024 发表</p></blockquote><p>转眼间 23年的就快过完了，回顾过往这一年的时间，貌似有些许的特殊，不至于和前几年一样是一个无聊又无趣。</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>两年的宁静，博客在23年重新绽放光彩。</p><p>23年共计写了 19 篇 文章其中阅读最多的 <a href="https://blog.ning.moe/posts/Spring-Security/">新版本 Spring-Security 配置踩坑</a>  共阅读了 227次 从Google 来的最多，文章是其次是<br><a href="https://blog.ning.moe/posts/Java-CAPTCHA-cloudflare/">Java 使用 CloudFlare Turnstile 验证码</a> 共阅读了 205次。在重新开始写博客之后 本站从 23年6月记录截稿，共收获了  PV <strong>6.52k</strong>  UV <strong>2.16k</strong>。</p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/12/29/658ed5482b2d5.webp" alt="2023-Blog-PV&amp;UV-Date.webp" style="zoom: 80%;"><blockquote><p>为什么只有6-12月的数据呢？</p><p><del>因为我把1-5月的数据搞丢了。</del></p></blockquote><p>在截稿前收到Google 发来的Email 28天从Google 来了120 的</p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/12/31/65916362b2813.webp" alt="Google-search-PV.webp" style="zoom:50%;"><h1 id="赛项"><a href="#赛项" class="headerlink" title="赛项"></a>赛项</h1><p>我参加了<code>应用软件系统开发</code>  荣获一等奖。然而，对于这次比赛，我心中并未留下太多深刻的评价，因为涉及的内容大多是繁琐且重复的工作。</p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/12/31/65916654c7cc0.webp" alt="ChinaSkills.webp" style="zoom: 50%;"><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>23年的故事就此落幕，还有23年所遇到的人们，也开启了我线下第一次面基之旅（不展开叙述）。24年的故事即将开启，这一年里展开新的冒险。我希望在24年，能够踏上旅途，探访不同的地方，因为美好的青春如此短暂，而旅行是拓展视野和经历的最佳方式。同时，我收集更多计算机知识的奥秘，为自己的技术之旅添上浓墨重彩的一笔。至于博客吗，我也会继续写下去的。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;blockquote&gt;
&lt;p&gt;应该这个文章会在 31/12/2024 发表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转眼间 23年的就快过完了，回顾过往这一年的时间，貌似有些许的特殊，不至于和前几年一样是一个无聊又无趣。&lt;/p</summary>
      
    
    
    
    <category term="生活随想" scheme="https://blog.ning.moe/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="总结" scheme="https://blog.ning.moe/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="2023" scheme="https://blog.ning.moe/tags/2023/"/>
    
  </entry>
  
  <entry>
    <title>TeamSpeak 已经运行一年</title>
    <link href="https://blog.ning.moe/posts/teamspeak-run-one-year/"/>
    <id>https://blog.ning.moe/posts/teamspeak-run-one-year/</id>
    <published>2023-11-06T13:32:10.000Z</published>
    <updated>2024-03-12T16:32:13.696Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><blockquote><p> <a href="ts3server://voice.ning.moe" rel="external nofollow noreferrer">点击此处唤醒</a>team speak</p></blockquote><p>看来 21多天没有更新了，来水一下，先浅浅的放一下运行一年的截图吧。</p><p> <img src="https://img.misaka.pics/ShellBlogImg/1/2023/11/06/6548eff53a156.webp" alt="TeamSpeak-one-year-1.webp"> </p><p>emmm ，艰难的存活了一年，感觉蛮不容易的，期间服务器很想进行重启的，应该来说是<a href="https://blog.ning.moe/blog/">两年之久</a>，在这个软件里面承载了我们之间的欢乐时光。</p><p> <img src="https://img.misaka.pics/ShellBlogImg/1/2023/11/06/6548f0c3abc56.webp" alt="TeamSpeak-one-year-2.webp"> </p><p>这个 TeamSpeak 服务器是在腾讯云hk轻量服务器上运行，用来方便我和我的朋友们进行连麦和交流。为我们提供了一个愉快的交流平台，让我们能够更轻松地一起玩游戏、讨论话题和共享欢乐时光。</p><p>我们主要的游戏是 彩虹六号，如果您也是彩虹六号玩家或者是对彩虹六号感兴趣，切没有人和你一起玩耍，我们非常欢迎你来加入我们，与我们一起畅谈、娱乐。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;blockquote&gt;
&lt;p&gt; &lt;a href=&quot;ts3server://voice.ning.moe&quot; rel=&quot;external nofollow noreferrer&quot;&gt;点击此处唤醒&lt;/a&gt;team speak&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="生活随想" scheme="https://blog.ning.moe/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="TeamSpeak" scheme="https://blog.ning.moe/tags/TeamSpeak/"/>
    
  </entry>
  
  <entry>
    <title>封印 Easyconnect</title>
    <link href="https://blog.ning.moe/posts/fuck-easyconnect/"/>
    <id>https://blog.ning.moe/posts/fuck-easyconnect/</id>
    <published>2023-10-15T16:02:08.000Z</published>
    <updated>2024-12-31T03:35:41.355Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="故事的起点"><a href="#故事的起点" class="headerlink" title="故事的起点"></a>故事的起点</h1><p>因为已经到了实习期，走<del>(滚)</del>出了学校,还要写这些烦人的周记属实难绷，还必须使用这个<code>Easyconnect</code>进行访问。</p><p>如果你只是想搜索 <code>Easyconnect</code>却看到了这一篇文章，那么您可以仔细权衡一下有必要再去下载和使用<code>Easyconnect</code>了,如果问为什么不要使用<code>Easyconnect</code>。您可以去跳转到<a href="https://taoshu.in/easyconnect-in-docker.html" rel="external nofollow noreferrer">这一篇文章</a>或者可以看我使用<code>Chat GPT</code>进行总结这一篇文章的核心。</p><blockquote><p>当讨论深信服的 EasyConnect 客户端的安全隐患时，可以简化描述如下：</p><ol><li><p><strong>依赖问题：</strong> EasyConnect 客户端使用了一些旧的系统功能，这在最新版本的 macOS 上会导致它无法正常工作。这就好比用一个老式的车钥匙开启现代汽车一样，不再适配。</p></li><li><p><strong>根证书问题：</strong> EasyConnect 客户端在你的电脑上安装了一个特殊的证书，而这个证书的作用可能不仅限于官方所说的提供更好的浏览体验。这有点像你的家门锁被复制一把，而你不知道。</p></li><li><p><strong>自启动问题：</strong> EasyConnect 客户端还有一个进程，名为 EasyMonitor，它在你的电脑开机时就自动启动。这个进程有权监听你的一举一动，而你却不能简单地关闭它，否则你无法使用 VPN 服务。</p></li></ol></blockquote><p>而且这个东西还是全局代理的，所有流量都要经过转发，以及可能会对一些游戏例如CSGO 进行冲突。</p><h1 id="需要准备的东西"><a href="#需要准备的东西" class="headerlink" title="需要准备的东西"></a>需要准备的东西</h1><ul><li>一台运行了 Windows/MAC os /Linux 的电脑</li><li>需要 docker 的使用</li><li>需要 vnc 的连接</li></ul><h1 id="开始启动"><a href="#开始启动" class="headerlink" title="开始启动"></a>开始启动</h1><p>当然有这种烦人的东西也就有大佬挺身而出，<a href="https://github.com/docker-easyconnect/docker-easyconnect" rel="external nofollow noreferrer">docker-easyconnect</a>就是来解决这个问题，使用docker 进行封印。</p><p>至于docker 和VNC的安装在这里就不进行赘述了，不是本篇文章的重点。使用以下命令运行docker 容器。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --device /dev/net/tun --cap-add NET_ADMIN -ti -e PASSWORD=xxxx -e URLWIN=1 -v ~/.ecdata:/root -p 5901:5901 -p 1080:1080 -p 8888:8888 hagb/docker-easyconnect:7.6.7</span><br></pre></td></tr></tbody></table></figure><p>windows 版本的：</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">--rm</span> <span class="literal">--device</span> /dev/net/tun <span class="literal">--cap-add</span> NET_ADMIN <span class="literal">-ti</span> <span class="literal">-e</span> PASSWORD=xxxx <span class="literal">-e</span> URLWIN=<span class="number">1</span> <span class="literal">-v</span> C:\Users\&lt;你的用户名&gt;\.ecdata:/root <span class="literal">-p</span> <span class="number">5901</span>:<span class="number">5901</span> <span class="literal">-p</span> <span class="number">1080</span>:<span class="number">1080</span> <span class="literal">-p</span> <span class="number">8888</span>:<span class="number">8888</span> hagb/docker<span class="literal">-easyconnect</span>:<span class="number">7.6</span>.<span class="number">7</span></span><br></pre></td></tr></tbody></table></figure><p>其中<code> -v ~/.ecdata:/root</code> 运行成功后会在你的用户目录下创建一个<code>.ecdata</code>文件夹里面保存了你的登陆信息，下一次运行的时候就可以不需要输入用户和密码以及连接地址了。</p><p>使用 <code>VNC</code> 连接就会发现和你在电脑版安装的之后页面是一样的输入连接的服务器地址以及账号和密码，记得勾选自动登录，下次启动的时候回去读取，你用户目录下的 <code>ecdata</code> 的文件。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/10/22/65347edfb2da2.webp" alt="VNC-1.webp"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>我们暴露的 <code>1080</code> 和 <code>8888</code> 的端口分别是 <code>socket5</code>代理和<code>http</code>代理。</p><p>Firefox 的浏览器的用户可以直接使用 设置 配置有个代理配置。</p><p>这里更推荐使用edge ，因为国内好下载插件 打开这个网址下载：<a href="https://microsoftedge.microsoft.com/addons/detail/proxy-switchyomega/fdbloeknjpnloaggplaobopplkdhnikc?hl=zh-CN" rel="external nofollow noreferrer">Proxy SwitchyOmega - Microsoft Edge Addons</a></p><p>我们打开插件的配置选项，按照下方图片的填写。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/10/22/65347b7f9620e.webp" alt="SwitchyOmega.webp"></p><p>然后选择 proxy 的代理组，访问完毕内网资源，记住调成 系统代理选项卡，不然这个安装这个浏览器的插件会无法上网。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/10/22/65347c0eac9b4.webp" alt="SwitchyOmega-1.webp"></p><h1 id="意外情况？"><a href="#意外情况？" class="headerlink" title="意外情况？"></a>意外情况？</h1><p>如果你运行第一次是没问题的但第二次运行之后报错:</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: Ports are not available: exposing port TCP <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">1080</span> -&gt; <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">0</span>: listen tcp <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">1080</span>: bind: An attempt was made to access a socket <span class="keyword">in</span> a way forbidden by its access permissions. time=<span class="string">"2023-10-15T10:13:34+08:00"</span> level=error msg=<span class="string">"error waiting for container: "</span></span><br></pre></td></tr></tbody></table></figure><p>是说明你的 1080 端口被占用了，你可以使用<code>netstat -aon | findstr :1080</code> 的命令进行查询如果发现没有程序出现问题的话。那就是其实这是Windows中的一个小问题，只需要重启NAT网络就可以解决了，执行如下两条命令：</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop winnat</span><br><span class="line">net <span class="built_in">start</span> winnat</span><br></pre></td></tr></tbody></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用涛叔博客 使用 Docker 封印 EasyConnect 一篇文章：<a href="https://taoshu.in/easyconnect-in-docker.html" rel="external nofollow noreferrer">https://taoshu.in/easyconnect-in-docker.html</a></p></body></html>]]></content>
    
    
    <summary type="html">这篇文章介绍了如何使用Docker封印EasyConnect，以解决其安全隐患和全局代理带来的问题。作者指出EasyConnect存在依赖旧系统功能、安装特殊证书和自启动进程等安全隐患。通过Docker容器化部署EasyConnect，可以方便地管理和使用，避免安全问题和全局代理的不便。文章简明扼要地介绍了部署步骤和解决端口占用问题的方法。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="2023" scheme="https://blog.ning.moe/tags/2023/"/>
    
    <category term="easyconnect" scheme="https://blog.ning.moe/tags/easyconnect/"/>
    
    <category term="深信服" scheme="https://blog.ning.moe/tags/%E6%B7%B1%E4%BF%A1%E6%9C%8D/"/>
    
    <category term="vpn" scheme="https://blog.ning.moe/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket用SpringSecuirty认证和鉴权</title>
    <link href="https://blog.ning.moe/posts/springboot-websocket-springSecurity/"/>
    <id>https://blog.ning.moe/posts/springboot-websocket-springSecurity/</id>
    <published>2023-09-10T15:59:15.000Z</published>
    <updated>2024-12-31T03:36:04.386Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚开始想进行认证感觉还是蛮简单的，也只需要让websocket 的<code>Headers</code>上也带<code>authorization</code>在加上token 的值不就完事了吗。</p><p>但websocket 不支持自定义<code>Headers</code>头所以不行，但ws 允许在<code>Sec-WebSocket-Protocol</code> 的请求头加入自定义的参数，也就是说只需要在spring security 中在加入一个对于<code>Sec-WebSocket-Protocol</code>的检测就行了。</p><h1 id="添加对-Sec-WebSocket-Protocol-的判断"><a href="#添加对-Sec-WebSocket-Protocol-的判断" class="headerlink" title="添加对 Sec-WebSocket-Protocol 的判断"></a>添加对 Sec-WebSocket-Protocol 的判断</h1><p>这里的<code>WSHeader</code>其实就是<code>Sec-WebSocket-Protocol</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取请求token</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String <span class="title function_">getToken</span><span class="params">(HttpServletRequest request)</span> {</span><br><span class="line">     <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(header);</span><br><span class="line">     <span class="keyword">if</span> (StringUtils.isNotEmpty(token) &amp;&amp; token.startsWith(Constants.TOKEN_PREFIX)) {</span><br><span class="line">         token = token.replace(Constants.TOKEN_PREFIX, <span class="string">""</span>);</span><br><span class="line">     } <span class="keyword">else</span> {</span><br><span class="line">         <span class="comment">//如果未从请求头中获取到token,则尝试从Sec-WebSocket-Protocol中取出</span></span><br><span class="line">         token = request.getHeader(WSHeader);</span><br><span class="line">         <span class="comment">//如果有值，一定要在response的header中设置，否则还是会断开</span></span><br><span class="line">         <span class="keyword">if</span> (StringUtils.isNotEmpty(token)) {</span><br><span class="line">             <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> ServletUtils.getResponse();</span><br><span class="line">             response.setHeader(WSHeader, token);</span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> token;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>经过这样的配置我们的<code>Websocket </code>的连接端点是肯定可以通过认证了，但还要拿到<code>SpringSecuiry</code>中的已经登录的用户，判断它是谁？</p><h1 id="添加获取用户信息"><a href="#添加获取用户信息" class="headerlink" title="添加获取用户信息"></a>添加获取用户信息</h1><p>首先配置好<code>Websocket </code>的配置</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入一个ServerEndpointExporter,该Bean会自动注册使用<span class="doctag">@ServerEndpoint</span>注解申明的websocket endpoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointExporter <span class="title function_">serverEndpointExporter</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointExporter</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里在配置一个<code>websocket </code>的连接接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint("/ws")</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketController</span> {</span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnOpen</span><span class="params">(Session session)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="built_in">this</span>.session = session;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnClose</span><span class="params">(Session session)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到每一个用户连入<code>/ws</code> 的这个都会有他们自己唯一一个<code>session</code> 其实如果要是直接 <code>session.</code>或有一个叫做 ``getUserPrincipal()<code> 的方法继续点下去有一个getName的方法。如果继续追下去打开</code>debug<code>就会惊奇的发现，</code>getUserPrincipal()<code>的类型尽然是SpringSecurity的</code>UsernamePasswordAuthenticationToken`的类，那么这就好办了。我写了一方法。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/09/19/6509235059a87.webp" alt="Spring-Security-Config-3.webp"></p><p>这里的<code>LoginUser</code>和<code>SysUser</code>是我已经重写好<code>SpringSecuriy</code>中的登录用户的类，请改成你自己的即可。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前登录用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> SysUser <span class="title function_">getSysUser</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">userPrincipal</span> <span class="operator">=</span> (UsernamePasswordAuthenticationToken) <span class="built_in">this</span>.session.getUserPrincipal();</span><br><span class="line">    <span class="type">LoginUser</span> <span class="variable">principal</span> <span class="operator">=</span> (LoginUser) userPrincipal.getPrincipal();</span><br><span class="line">    <span class="keyword">return</span> principal.getUser();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <summary type="html">本文介绍了如何利用Spring Security对WebSocket进行认证和鉴权。作者解决了WebSocket无法自定义Headers头的问题，通过检测Sec-WebSocket-Protocol请求头实现了认证。随后，作者展示了如何在WebSocket配置中获取已登录的Spring Security用户信息，并提供了获取当前登录用户信息的方法。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="2023" scheme="https://blog.ning.moe/tags/2023/"/>
    
    <category term="Spring" scheme="https://blog.ning.moe/tags/Spring/"/>
    
    <category term="Java" scheme="https://blog.ning.moe/tags/Java/"/>
    
    <category term="Security" scheme="https://blog.ning.moe/tags/Security/"/>
    
    <category term="SpringSecuriy" scheme="https://blog.ning.moe/tags/SpringSecuriy/"/>
    
    <category term="WebSocket" scheme="https://blog.ning.moe/tags/WebSocket/"/>
    
  </entry>
  
</feed>
