<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>某科学的贝壳</title>
  
  <subtitle>一个贝壳的博客</subtitle>
  <link href="https://blog.ning.moe/atom.xml" rel="self"/>
  
  <link href="https://blog.ning.moe/"/>
  <updated>2024-04-24T03:02:38.043Z</updated>
  <id>https://blog.ning.moe/</id>
  
  <author>
    <name>shell</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Cloud Flare Tunnel和 Acces Application安全的暴露在公网</title>
    <link href="https://blog.ning.moe/posts/CloudFlare-Tunnel-Application-Access/"/>
    <id>https://blog.ning.moe/posts/CloudFlare-Tunnel-Application-Access/</id>
    <published>2024-04-23T01:43:40.000Z</published>
    <updated>2024-04-24T03:02:38.043Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>如果搞 Home Lab 始终绕不开的话题是，我们如何将自己的内网服务暴露到公网上，又如何保证我们的安全。<br>现在可以使用我们赛博菩萨 Cloudflare 提供的 Zero Trust 来保护我们的安全。</p><p>演示的dome ： <a href="https://hp.ning.moe/" rel="external nofollow noreferrer">HomePage</a> 和 <a href="https://misakashell.cloudflareaccess.com/" rel="external nofollow noreferrer">Cloud Flare Zero Trust 主页</a></p><h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><h2 id="使用-Tunnel-暴露服务"><a href="#使用-Tunnel-暴露服务" class="headerlink" title="使用 Tunnel 暴露服务"></a>使用 Tunnel 暴露服务</h2><p>我们需要先登录<a href="https://one.dash.cloudflare.com/" rel="external nofollow noreferrer">CF zero trust的管理平台</a>，添加新的隧道点击：<code>Networks/Tunnels</code> 我们需要添加一个隧道让我们本地和 <code>Cloudflare Zero Trust</code>服务器进行连接。简单的配置完隧道名字</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/22/6626359570249.webp" alt="Cloud-Flare-Zero-Trust-Dash-Tunnels.webp"></p><p>会自动跳转到tunnel 这个页面，没跳转的 Networks/Tunnels/你的隧道/config。我们需要安装一个cloudflared的程序，这个页面已经为我们提供好了常见的系统，如Linux MacOS Windows，复制命令直接在我们终端运行即可。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/22/66263669cc5c3.webp" alt="CloudFlared-Download.webp"></p><p>然后 下一步 ，简单配置一下。保存即可。返回菜单会发现刚刚创建的 <code>Tunnel</code> 等待 <code>Status</code> 显示<code>HEALTHY</code> 访问你的 配置好的域名应该就可以访问了。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/22/6626371255c1f.webp" alt="Cloud-Flare-Tunnel-Config.webp"></p><h2 id="使用-Access-Applications-认证"><a href="#使用-Access-Applications-认证" class="headerlink" title="使用 Access Applications 认证"></a>使用 Access Applications 认证</h2><p>首先你需要确保你有登录方式 <code>Settings</code> –&gt;<code>Authentication</code>–&gt;<code>Login methods</code> ,如果没有你需要自行创建。</p><p>来到<code> Access</code> –&gt;<code> Applications</code> –&gt; <code> Add an application</code> 选择<code>Self-hosted</code>，填写你刚才的域名，然后下一步。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/22/66263cfec6386.webp" alt="CF-Access-Applications.webp"></p><p><code>policy name</code> 可以随便填写 记得 <code>Action</code>是 <code>Allow</code>，这里的Session 是多久在进行登录验证，可以调节时间长一点。</p><p><code>Create additional rules</code> 根据你刚才配置的 <code>Authentication</code> 来填写，我这里是填写CF自带的邮箱验证码进行登录的。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/22/66263cff40b37.webp" alt="CF-Add an application.webp"></p><p>配置完毕之后，访问你配置的域名就会出现拦截了，例如我<a href="https://hp.ning.moe/" rel="external nofollow noreferrer">配置好的</a>这我设置了自动跳转所以会到我的<code>SSO.ning.moe</code></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/" rel="external nofollow noreferrer">Cloudflare Tunnel 配置文档</a></p><p><a href="https://developers.cloudflare.com/cloudflare-one/applications/" rel="external nofollow noreferrer">Applications Access</a></p></body></html>]]></content>
    
    
    <summary type="html">利用 Cloudflare 提供的 Zero Trust 解决方案，将内网服务安全地暴露到公网的方法。通过配置 Tunnel 和 Access Applications，我们可以轻松实现安全连接和认证，确保数据传输和访问的安全性。这一方案简单易用，为 Home Lab 的搭建提供了可靠的安全保障。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="CloudFlare" scheme="https://blog.ning.moe/tags/CloudFlare/"/>
    
    <category term="Zero Trust" scheme="https://blog.ning.moe/tags/Zero-Trust/"/>
    
  </entry>
  
  <entry>
    <title>Memos 对接 Authentik</title>
    <link href="https://blog.ning.moe/posts/authentik-OAuth2-memos/"/>
    <id>https://blog.ning.moe/posts/authentik-OAuth2-memos/</id>
    <published>2024-04-09T14:40:34.000Z</published>
    <updated>2024-04-24T03:00:28.498Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><blockquote><p> 配置中：这是什么啊，这么麻烦还没过去啊。 配置后：真香好方便。</p></blockquote><p>使用本文前请自行在 <code>Authentik </code>配置好 Memos使用的<code>应用程序</code>和<code>提供程序</code></p><h1 id="Authentik-配置"><a href="#Authentik-配置" class="headerlink" title="Authentik 配置"></a>Authentik 配置</h1><p>默认你已经创建好了，一个给Memos使用的<code>应用程序</code>和<code>提供程序</code>,我们需要更改<code>提供程序</code>(给Memos 的)我们点击编辑</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/09/66155d6445bbc.webp" alt="Authentik 配置 Memos-1.webp"></p><blockquote><p>选择客户端可以使用哪些作用域。客户端仍然需要指定访问数据的范围。</p><p>按住 <code>ctrl/command</code> 键可选择多个项目。</p></blockquote><p>我们选中<code>authentik default OAuth Mapping: OpenID email</code> 和 <code>authentik default OAuth Mapping: OpenID openid</code>将<code>Subject 模式</code>改成基于用户名，然后更新。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/09/6615597f90737.webp" alt="Authentik 配置 Memos.webp"></p><h1 id="Memos配置"><a href="#Memos配置" class="headerlink" title="Memos配置"></a>Memos配置</h1><blockquote><p>在截至发文时 <code>Memos</code> 的版本为<code>v0.20.1</code>版本，<code>Memos</code>通过用户名为主键，其实只需要给<code>username</code>字段即可。</p></blockquote><p>根据上文调整的，现在sub 是我们的用户名字段，按照文章截屏填写其他的自行替换。这样你的的<code>Memos</code>就可以使用<code>Authentik</code>进行登录了。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/04/09/66155e6ca6dc7.webp" alt="Memos-Oauth2-config.webp"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><code>Memos</code>的文档：<a href="https://www.usememos.com/docs/advanced-settings/keycloak" rel="external nofollow noreferrer">https://www.usememos.com/docs/advanced-settings/keycloak</a></p></body></html>]]></content>
    
    
    <summary type="html">Authentik uses OAuth2 to interface with Memos. Authentik 使用 OAuth2 对接 Memos</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Memos" scheme="https://blog.ning.moe/tags/Memos/"/>
    
    <category term="Authentik" scheme="https://blog.ning.moe/tags/Authentik/"/>
    
    <category term="SSO" scheme="https://blog.ning.moe/tags/SSO/"/>
    
    <category term="OAuth2" scheme="https://blog.ning.moe/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>爱快IPv6防火墙配置</title>
    <link href="https://blog.ning.moe/posts/Ikuai-firewall-IPv6/"/>
    <id>https://blog.ning.moe/posts/Ikuai-firewall-IPv6/</id>
    <published>2024-03-01T15:59:59.000Z</published>
    <updated>2024-04-09T15:41:36.709Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>爱快尽然默认没有开启<code>IPv6</code>对内网设备的阻断，我发现的时候十分震惊，而且已经在公网上暴露有一天以上了，最糟糕的事情，内网设备的密码全部是弱密码，吓得我先立刻断掉<code>IPv6</code>接入，仔细排查了一下内网设备还好没有人扫到并且进行爆破。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>请确保你的<code>ikuai </code>系统是最新版本并且登录<code>ikuai Web</code>后台，<code>安全设置</code> –&gt;<code>ACL规则</code></p><h2 id="阻断所有IPv6链接"><a href="#阻断所有IPv6链接" class="headerlink" title="阻断所有IPv6链接"></a>阻断所有IPv6链接</h2><blockquote><p>此操作不会阻断响应<code>IPv6</code>的流量</p></blockquote><p>由于 <code>ikuai </code>在 3.7.11 版本还不支持放行或阻断<code> ICMP</code> 协议，如果您想外网设备能ping通内网的话，需要需要创建两个配置，一个是阻断<code>TCP</code>还有一个阻断<code>UDP</code>，不想<code>ping</code>通的话，只需要创建一个配置选择任意协议即可。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/03/06/65e834d3a0bdd.webp" alt="ipv6防护墙介绍.webp"></p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/03/06/65e834d40ca02.webp" alt="ipv6阻断.webp"></p><p>进接口一定是<code>wan</code>口由于笔者只有一个<code>wan</code>口，如果您有多个话请务必全部勾选，出接口是<code>lan</code>同样如果您有多个<code>lan</code>接口请全部勾上，这样我们内网设备就不会暴露外网了。</p><h2 id="打开指定IPv6的连接"><a href="#打开指定IPv6的连接" class="headerlink" title="打开指定IPv6的连接"></a>打开指定IPv6的连接</h2><blockquote><p>再说指定放行<code>IPv6</code>地址，如果您是静态<code>IPv6</code>，那你自己放行那个ip 即可，但是身为家庭宽带的话都是动态<code>IPv6</code>地址根本不可能知道ip会变成什么样子，还是说每次变化ip 的地址重新改吗？这里需要了解一下ipv6 的后缀生成是受MAC 地址影响的，通过EUI-64 编码进行处理，详情访问: <a href="https://ccie.lol/knowledge-base/ipv6-use-eui-64-convert-link-local-address/" rel="external nofollow noreferrer">【转】通过EUI-64自动生成IPv6地址和IPv6链路本地地址（Link-Local Address）</a></p></blockquote><p><strong>对于windows 获取ipv6地址使用 EUI-64 编码得到的理论值和实际值可能不一样</strong></p><p>可以使用 <a href="https://eui64-calc.princelle.org/" rel="external nofollow noreferrer">EUI-64 计算器</a></p><p>例如 <code>bc:34:11:c6:8a:19 </code>通过计算可以得到 <code>BE34:11FF:FEC6:8A19</code> 理论情况的<code>ipv6</code>，据我测试后四位基本上都是一样的，前面受到<code>IPv6</code>前缀影响。</p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/03/06/65e846c30a412.webp" alt="指定IPv6放行.webp" style="zoom:67%;"><p>在已经匹配的内容中<code>::8A19</code>改成你自己的后缀四位，<code>ikuai </code>的防火墙逻辑是先放行后阻断，所以不需要关系防火墙配置的顺序。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::8a1f/::ffff</span><br></pre></td></tr></tbody></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://ccie.lol/knowledge-base/ipv6-use-eui-64-convert-link-local-address/" rel="external nofollow noreferrer">【转】通过EUI-64自动生成IPv6地址和IPv6链路本地地址（Link-Local Address）</a></p><p> <a href="https://eui64-calc.princelle.org/" rel="external nofollow noreferrer">EUI-64 计算器</a></p></body></html>]]></content>
    
    
    <summary type="html">这篇博客介绍了如何在爱快系统中配置IPv6防火墙。作者指出系统默认未开启IPv6阻断，存在安全隐患，提供了阻断和放行IPv6连接的配置方法，同时解释了EUI-64编码生成IPv6地址的过程。适用于爱快系统用户保护内网设备安全。</summary>
    
    
    
    
    <category term="Ikuai" scheme="https://blog.ning.moe/tags/Ikuai/"/>
    
    <category term="防火墙" scheme="https://blog.ning.moe/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
    <category term="firewall" scheme="https://blog.ning.moe/tags/firewall/"/>
    
    <category term="IPv6" scheme="https://blog.ning.moe/tags/IPv6/"/>
    
  </entry>
  
  <entry>
    <title>改造家里网络</title>
    <link href="https://blog.ning.moe/posts/Home-NetWork/"/>
    <id>https://blog.ning.moe/posts/Home-NetWork/</id>
    <published>2024-02-08T03:13:49.000Z</published>
    <updated>2024-03-12T16:32:13.689Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>也好久没更新来水一波。</p></blockquote><p>寒假里面，打算在折腾一下家里面的网络，将家里21年买的<code>r2s</code>换成<code>J4125</code>这下就够我折腾的了。</p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/03/06/65e8108d61fe7.webp" alt="网络拓补图.webp" style="zoom:50%;"><p>这是我目前的家里主题结构 由<code>r2s</code>软路由担任<code>PPPOE</code>拨号，有两个<code>AP</code> 组成有线<code>mesh</code>。</p><p>对于 <code>J4125 </code>我打算使用<code>PVE</code>+<code>Ikuai</code>+<code>Debian</code></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="折腾前的痛点"><a href="#折腾前的痛点" class="headerlink" title="折腾前的痛点"></a>折腾前的痛点</h2><ul><li>稳定：对于<code>r2s</code>来说有时候不是特别问题定，需要定时重启，我尝试换了很多的固件，都无法解决此问题</li><li>性能不足 ：<code>r2s</code>有人测试基本上稳定千兆是没有问题的了（在不使用科学上网的时候），但对于小包转发来说多少有些吃力。</li><li>ARM 生态问题：我知道ARM 发展的很好，但很多老的程序还只能支持<code>X86</code>.</li></ul><h2 id="折腾解决之后的"><a href="#折腾解决之后的" class="headerlink" title="折腾解决之后的"></a>折腾解决之后的</h2><ul><li>稳定：目前连续运行了20天没有发现异常</li><li>性能：<code>J4125</code>妥妥够我300mbps 的带宽使用了（满载带宽，CPU占用15%~20%）</li><li>软件：解决了ARM 部分软件问题。</li></ul><p><code>J4125</code>进行<code>PVE </code>虚拟化，由<code>Ikuai </code>作为主路由进行<code>PPPOE</code> 以及流控管理，<code>Debian`` docker</code> 化跑<code>Adguard Heome </code>家用<code>DNS </code>。</p><img src="https://img.misaka.pics/ShellBlogImg/1/2024/03/06/65e82e1b241e5.webp" alt="网络拓补图-2.webp" style="zoom: 67%;"></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;也好久没更新来水一波。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p</summary>
      
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Ikuai" scheme="https://blog.ning.moe/tags/Ikuai/"/>
    
    <category term="J4125" scheme="https://blog.ning.moe/tags/J4125/"/>
    
  </entry>
  
  <entry>
    <title>2023 总结</title>
    <link href="https://blog.ning.moe/posts/2023-Annual-Summary/"/>
    <id>https://blog.ning.moe/posts/2023-Annual-Summary/</id>
    <published>2023-12-31T15:59:59.000Z</published>
    <updated>2024-03-12T16:32:13.688Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><blockquote><p>应该这个文章会在 31/12/2024 发表</p></blockquote><p>转眼间 23年的就快过完了，回顾过往这一年的时间，貌似有些许的特殊，不至于和前几年一样是一个无聊又无趣。</p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>两年的宁静，博客在23年重新绽放光彩。</p><p>23年共计写了 19 篇 文章其中阅读最多的 <a href="https://blog.ning.moe/posts/Spring-Security/">新版本 Spring-Security 配置踩坑</a>  共阅读了 227次 从Google 来的最多，文章是其次是<br><a href="https://blog.ning.moe/posts/Java-CAPTCHA-cloudflare/">Java 使用 CloudFlare Turnstile 验证码</a> 共阅读了 205次。在重新开始写博客之后 本站从 23年6月记录截稿，共收获了  PV <strong>6.52k</strong>  UV <strong>2.16k</strong>。</p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/12/29/658ed5482b2d5.webp" alt="2023-Blog-PV&amp;UV-Date.webp" style="zoom: 80%;"><blockquote><p>为什么只有6-12月的数据呢？</p><p><del>因为我把1-5月的数据搞丢了。</del></p></blockquote><p>在截稿前收到Google 发来的Email 28天从Google 来了120 的</p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/12/31/65916362b2813.webp" alt="Google-search-PV.webp" style="zoom:50%;"><h1 id="赛项"><a href="#赛项" class="headerlink" title="赛项"></a>赛项</h1><p>我参加了<code>应用软件系统开发</code>  荣获一等奖。然而，对于这次比赛，我心中并未留下太多深刻的评价，因为涉及的内容大多是繁琐且重复的工作。</p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/12/31/65916654c7cc0.webp" alt="ChinaSkills.webp" style="zoom: 50%;"><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>23年的故事就此落幕，还有23年所遇到的人们，也开启了我线下第一次面基之旅（不展开叙述）。24年的故事即将开启，这一年里展开新的冒险。我希望在24年，能够踏上旅途，探访不同的地方，因为美好的青春如此短暂，而旅行是拓展视野和经历的最佳方式。同时，我收集更多计算机知识的奥秘，为自己的技术之旅添上浓墨重彩的一笔。至于博客吗，我也会继续写下去的。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;blockquote&gt;
&lt;p&gt;应该这个文章会在 31/12/2024 发表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转眼间 23年的就快过完了，回顾过往这一年的时间，貌似有些许的特殊，不至于和前几年一样是一个无聊又无趣。&lt;/p</summary>
      
    
    
    
    
    <category term="总结" scheme="https://blog.ning.moe/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="2023" scheme="https://blog.ning.moe/tags/2023/"/>
    
  </entry>
  
  <entry>
    <title>TeamSpeak 已经运行一年</title>
    <link href="https://blog.ning.moe/posts/teamspeak-run-one-year/"/>
    <id>https://blog.ning.moe/posts/teamspeak-run-one-year/</id>
    <published>2023-11-06T13:32:10.000Z</published>
    <updated>2024-03-12T16:32:13.696Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><blockquote><p> <a href="ts3server://voice.ning.moe" rel="external nofollow noreferrer">点击此处唤醒</a>team speak</p></blockquote><p>看来 21多天没有更新了，来水一下，先浅浅的放一下运行一年的截图吧。</p><p> <img src="https://img.misaka.pics/ShellBlogImg/1/2023/11/06/6548eff53a156.webp" alt="TeamSpeak-one-year-1.webp"> </p><p>emmm ，艰难的存活了一年，感觉蛮不容易的，期间服务器很想进行重启的，应该来说是<a href="https://blog.ning.moe/blog/">两年之久</a>，在这个软件里面承载了我们之间的欢乐时光。</p><p> <img src="https://img.misaka.pics/ShellBlogImg/1/2023/11/06/6548f0c3abc56.webp" alt="TeamSpeak-one-year-2.webp"> </p><p>这个 TeamSpeak 服务器是在腾讯云hk轻量服务器上运行，用来方便我和我的朋友们进行连麦和交流。为我们提供了一个愉快的交流平台，让我们能够更轻松地一起玩游戏、讨论话题和共享欢乐时光。</p><p>我们主要的游戏是 彩虹六号，如果您也是彩虹六号玩家或者是对彩虹六号感兴趣，切没有人和你一起玩耍，我们非常欢迎你来加入我们，与我们一起畅谈、娱乐。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;blockquote&gt;
&lt;p&gt; &lt;a href=&quot;ts3server://voice.ning.moe&quot; rel=&quot;external nofollow noreferrer&quot;&gt;点击此处唤醒&lt;/a&gt;team speak&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="生活随想" scheme="https://blog.ning.moe/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="TeamSpeak" scheme="https://blog.ning.moe/tags/TeamSpeak/"/>
    
  </entry>
  
  <entry>
    <title>封印 Easyconnect</title>
    <link href="https://blog.ning.moe/posts/fuck-easyconnect/"/>
    <id>https://blog.ning.moe/posts/fuck-easyconnect/</id>
    <published>2023-10-15T16:02:08.000Z</published>
    <updated>2024-04-09T15:48:37.174Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="故事的起点"><a href="#故事的起点" class="headerlink" title="故事的起点"></a>故事的起点</h1><p>因为已经到了实习期，走<del>(滚)</del>出了学校,还要写这些烦人的周记属实难绷，还必须使用这个<code>Easyconnect</code>进行访问。</p><p>如果你只是想搜索 <code>Easyconnect</code>却看到了这一篇文章，那么您可以仔细权衡一下有必要再去下载和使用<code>Easyconnect</code>了,如果问为什么不要使用<code>Easyconnect</code>。您可以去跳转到<a href="https://taoshu.in/easyconnect-in-docker.html" rel="external nofollow noreferrer">这一篇文章</a>或者可以看我使用<code>Chat GPT</code>进行总结这一篇文章的核心。</p><blockquote><p>当讨论深信服的 EasyConnect 客户端的安全隐患时，可以简化描述如下：</p><ol><li><p><strong>依赖问题：</strong> EasyConnect 客户端使用了一些旧的系统功能，这在最新版本的 macOS 上会导致它无法正常工作。这就好比用一个老式的车钥匙开启现代汽车一样，不再适配。</p></li><li><p><strong>根证书问题：</strong> EasyConnect 客户端在你的电脑上安装了一个特殊的证书，而这个证书的作用可能不仅限于官方所说的提供更好的浏览体验。这有点像你的家门锁被复制一把，而你不知道。</p></li><li><p><strong>自启动问题：</strong> EasyConnect 客户端还有一个进程，名为 EasyMonitor，它在你的电脑开机时就自动启动。这个进程有权监听你的一举一动，而你却不能简单地关闭它，否则你无法使用 VPN 服务。</p></li></ol></blockquote><p>而且这个东西还是全局代理的，所有流量都要经过转发，以及可能会对一些游戏例如CSGO 进行冲突。</p><h1 id="需要准备的东西"><a href="#需要准备的东西" class="headerlink" title="需要准备的东西"></a>需要准备的东西</h1><ul><li>一台运行了 Windows/MAC os /Linux 的电脑</li><li>需要 docker 的使用</li><li>需要 vnc 的连接</li></ul><h1 id="开始启动"><a href="#开始启动" class="headerlink" title="开始启动"></a>开始启动</h1><p>当然有这种烦人的东西也就有大佬挺身而出，<a href="https://github.com/docker-easyconnect/docker-easyconnect" rel="external nofollow noreferrer">docker-easyconnect</a>就是来解决这个问题，使用docker 进行封印。</p><p>至于docker 和VNC的安装在这里就不进行赘述了，不是本篇文章的重点。使用以下命令运行docker 容器。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --device /dev/net/tun --cap-add NET_ADMIN -ti -e PASSWORD=xxxx -e URLWIN=1 -v ~/.ecdata:/root -p 5901:5901 -p 1080:1080 -p 8888:8888 hagb/docker-easyconnect:7.6.7</span><br></pre></td></tr></tbody></table></figure><p>windows 版本的：</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">--rm</span> <span class="literal">--device</span> /dev/net/tun <span class="literal">--cap-add</span> NET_ADMIN <span class="literal">-ti</span> <span class="literal">-e</span> PASSWORD=xxxx <span class="literal">-e</span> URLWIN=<span class="number">1</span> <span class="literal">-v</span> C:\Users\&lt;你的用户名&gt;\.ecdata:/root <span class="literal">-p</span> <span class="number">5901</span>:<span class="number">5901</span> <span class="literal">-p</span> <span class="number">1080</span>:<span class="number">1080</span> <span class="literal">-p</span> <span class="number">8888</span>:<span class="number">8888</span> hagb/docker<span class="literal">-easyconnect</span>:<span class="number">7.6</span>.<span class="number">7</span></span><br></pre></td></tr></tbody></table></figure><p>其中<code> -v ~/.ecdata:/root</code> 运行成功后会在你的用户目录下创建一个<code>.ecdata</code>文件夹里面保存了你的登陆信息，下一次运行的时候就可以不需要输入用户和密码以及连接地址了。</p><p>使用 <code>VNC</code> 连接就会发现和你在电脑版安装的之后页面是一样的输入连接的服务器地址以及账号和密码，记得勾选自动登录，下次启动的时候回去读取，你用户目录下的 <code>ecdata</code> 的文件。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/10/22/65347edfb2da2.webp" alt="VNC-1.webp"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>我们暴露的 <code>1080</code> 和 <code>8888</code> 的端口分别是 <code>socket5</code>代理和<code>http</code>代理。</p><p>Firefox 的浏览器的用户可以直接使用 设置 配置有个代理配置。</p><p>这里更推荐使用edge ，因为国内好下载插件 打开这个网址下载：<a href="https://microsoftedge.microsoft.com/addons/detail/proxy-switchyomega/fdbloeknjpnloaggplaobopplkdhnikc?hl=zh-CN" rel="external nofollow noreferrer">Proxy SwitchyOmega - Microsoft Edge Addons</a></p><p>我们打开插件的配置选项，按照下方图片的填写。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/10/22/65347b7f9620e.webp" alt="SwitchyOmega.webp"></p><p>然后选择 proxy 的代理组，访问完毕内网资源，记住调成 系统代理选项卡，不然这个安装这个浏览器的插件会无法上网。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/10/22/65347c0eac9b4.webp" alt="SwitchyOmega-1.webp"></p><h1 id="意外情况？"><a href="#意外情况？" class="headerlink" title="意外情况？"></a>意外情况？</h1><p>如果你运行第一次是没问题的但第二次运行之后报错:</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: Ports are not available: exposing port TCP <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">1080</span> -&gt; <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">0</span>: listen tcp <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">1080</span>: bind: An attempt was made to access a socket <span class="keyword">in</span> a way forbidden by its access permissions. time=<span class="string">"2023-10-15T10:13:34+08:00"</span> level=error msg=<span class="string">"error waiting for container: "</span></span><br></pre></td></tr></tbody></table></figure><p>是说明你的 1080 端口被占用了，你可以使用<code>netstat -aon | findstr :1080</code> 的命令进行查询如果发现没有程序出现问题的话。那就是其实这是Windows中的一个小问题，只需要重启NAT网络就可以解决了，执行如下两条命令：</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop winnat</span><br><span class="line">net <span class="built_in">start</span> winnat</span><br></pre></td></tr></tbody></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用涛叔博客 使用 Docker 封印 EasyConnect 一篇文章：<a href="https://taoshu.in/easyconnect-in-docker.html" rel="external nofollow noreferrer">https://taoshu.in/easyconnect-in-docker.html</a></p></body></html>]]></content>
    
    
    <summary type="html">这篇文章介绍了如何使用Docker封印EasyConnect，以解决其安全隐患和全局代理带来的问题。作者指出EasyConnect存在依赖旧系统功能、安装特殊证书和自启动进程等安全隐患。通过Docker容器化部署EasyConnect，可以方便地管理和使用，避免安全问题和全局代理的不便。文章简明扼要地介绍了部署步骤和解决端口占用问题的方法。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="easyconnect" scheme="https://blog.ning.moe/tags/easyconnect/"/>
    
    <category term="深信服" scheme="https://blog.ning.moe/tags/%E6%B7%B1%E4%BF%A1%E6%9C%8D/"/>
    
    <category term="vpn" scheme="https://blog.ning.moe/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket用SpringSecuirty认证和鉴权</title>
    <link href="https://blog.ning.moe/posts/springboot-websocket-springSecurity/"/>
    <id>https://blog.ning.moe/posts/springboot-websocket-springSecurity/</id>
    <published>2023-09-10T15:59:15.000Z</published>
    <updated>2024-04-09T15:46:35.046Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚开始想进行认证感觉还是蛮简单的，也只需要让websocket 的<code>Headers</code>上也带<code>authorization</code>在加上token 的值不就完事了吗。</p><p>但websocket 不支持自定义<code>Headers</code>头所以不行，但ws 允许在<code>Sec-WebSocket-Protocol</code> 的请求头加入自定义的参数，也就是说只需要在spring security 中在加入一个对于<code>Sec-WebSocket-Protocol</code>的检测就行了。</p><h1 id="添加对-Sec-WebSocket-Protocol-的判断"><a href="#添加对-Sec-WebSocket-Protocol-的判断" class="headerlink" title="添加对 Sec-WebSocket-Protocol 的判断"></a>添加对 Sec-WebSocket-Protocol 的判断</h1><p>这里的<code>WSHeader</code>其实就是<code>Sec-WebSocket-Protocol</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取请求token</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String <span class="title function_">getToken</span><span class="params">(HttpServletRequest request)</span> {</span><br><span class="line">     <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(header);</span><br><span class="line">     <span class="keyword">if</span> (StringUtils.isNotEmpty(token) &amp;&amp; token.startsWith(Constants.TOKEN_PREFIX)) {</span><br><span class="line">         token = token.replace(Constants.TOKEN_PREFIX, <span class="string">""</span>);</span><br><span class="line">     } <span class="keyword">else</span> {</span><br><span class="line">         <span class="comment">//如果未从请求头中获取到token,则尝试从Sec-WebSocket-Protocol中取出</span></span><br><span class="line">         token = request.getHeader(WSHeader);</span><br><span class="line">         <span class="comment">//如果有值，一定要在response的header中设置，否则还是会断开</span></span><br><span class="line">         <span class="keyword">if</span> (StringUtils.isNotEmpty(token)) {</span><br><span class="line">             <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> ServletUtils.getResponse();</span><br><span class="line">             response.setHeader(WSHeader, token);</span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> token;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>经过这样的配置我们的<code>Websocket </code>的连接端点是肯定可以通过认证了，但还要拿到<code>SpringSecuiry</code>中的已经登录的用户，判断它是谁？</p><h1 id="添加获取用户信息"><a href="#添加获取用户信息" class="headerlink" title="添加获取用户信息"></a>添加获取用户信息</h1><p>首先配置好<code>Websocket </code>的配置</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入一个ServerEndpointExporter,该Bean会自动注册使用<span class="doctag">@ServerEndpoint</span>注解申明的websocket endpoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointExporter <span class="title function_">serverEndpointExporter</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointExporter</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里在配置一个<code>websocket </code>的连接接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint("/ws")</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketController</span> {</span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnOpen</span><span class="params">(Session session)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="built_in">this</span>.session = session;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OnClose</span><span class="params">(Session session)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到每一个用户连入<code>/ws</code> 的这个都会有他们自己唯一一个<code>session</code> 其实如果要是直接 <code>session.</code>或有一个叫做 ``getUserPrincipal()<code> 的方法继续点下去有一个getName的方法。如果继续追下去打开</code>debug<code>就会惊奇的发现，</code>getUserPrincipal()<code>的类型尽然是SpringSecurity的</code>UsernamePasswordAuthenticationToken`的类，那么这就好办了。我写了一方法。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/09/19/6509235059a87.webp" alt="Spring-Security-Config-3.webp"></p><p>这里的<code>LoginUser</code>和<code>SysUser</code>是我已经重写好<code>SpringSecuriy</code>中的登录用户的类，请改成你自己的即可。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前登录用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> SysUser <span class="title function_">getSysUser</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">userPrincipal</span> <span class="operator">=</span> (UsernamePasswordAuthenticationToken) <span class="built_in">this</span>.session.getUserPrincipal();</span><br><span class="line">    <span class="type">LoginUser</span> <span class="variable">principal</span> <span class="operator">=</span> (LoginUser) userPrincipal.getPrincipal();</span><br><span class="line">    <span class="keyword">return</span> principal.getUser();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    
    <summary type="html">本文介绍了如何利用Spring Security对WebSocket进行认证和鉴权。作者解决了WebSocket无法自定义Headers头的问题，通过检测Sec-WebSocket-Protocol请求头实现了认证。随后，作者展示了如何在WebSocket配置中获取已登录的Spring Security用户信息，并提供了获取当前登录用户信息的方法。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Spring" scheme="https://blog.ning.moe/tags/Spring/"/>
    
    <category term="Java" scheme="https://blog.ning.moe/tags/Java/"/>
    
    <category term="Security" scheme="https://blog.ning.moe/tags/Security/"/>
    
    <category term="SpringSecuriy" scheme="https://blog.ning.moe/tags/SpringSecuriy/"/>
    
    <category term="WebSocket" scheme="https://blog.ning.moe/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Cachefly自动证书上传</title>
    <link href="https://blog.ning.moe/posts/CacheflySSLUpDate/"/>
    <id>https://blog.ning.moe/posts/CacheflySSLUpDate/</id>
    <published>2023-07-31T09:07:10.000Z</published>
    <updated>2024-03-12T16:32:13.689Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自从 <code>Cachefly</code> 推出了<a href="https://www.cachefly.com/pricing/" rel="external nofollow noreferrer">免费套餐</a>， 作为一个白嫖党，第一时间就去体验了一下，注册需要外币卡需要注意一下，所以注册门槛稍微相对较高吧。试了一下速度，很不错，回国速度非常好，北方基本上走的是ntt 和俄罗斯的线路，南方走的是 hk 的CN2 线路，至少分发的图片和静态资源不成问题。</p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/08/02/64ca088d41e00.webp" alt="Cachefly-ItDog.webp"></p><p>但有个很烦人的问题，它不支持 免费的证书自动签发，需要我自己上传证书，好在他的ssl 证书是自动检测的，也就是说你上传了一个证书是在8月份到期了在7月份又上传了这个域名的证书是11月到期了，会自动在证书过期之前调整成11月的。而且最近学了学go，就用这三脚猫的功夫配合chatGPT 写了一个简单的小玩意。</p><h1 id="自动证书上传程序"><a href="#自动证书上传程序" class="headerlink" title="自动证书上传程序"></a>自动证书上传程序</h1><p>我已经把这个项目开源并且放在了 <a href="https://github.com/biliblihuorong/CacheflySSLUpDate" rel="external nofollow noreferrer">我的GitHub仓库上</a> 。</p><p>其实在仓库的README的文件上已经有写了使用方式，我就直接把README拿过来了。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ol><li><p>首先，您需要在 <a href="https://github.com/biliblihuorong/CacheflySSLUpDate/releases" rel="external nofollow noreferrer">https://github.com/biliblihuorong/CacheflySSLUpDate/releases</a> 页面下载适用于您设备的可执行文件。</p></li><li><p>然后，在执行文件所在目录下创建一个名为 <code>config.json</code> 的文件，并按照以下示例填入相应的内容。您也可以直接下载本仓库中的 <code>config.json</code> 文件，填入您的配置信息。</p></li></ol><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"token"</span><span class="punctuation">:</span> <span class="string">"您的 Cachefly Token，可在 https://portal.cachefly.com/app/tokens 获取"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"certificateFile"</span><span class="punctuation">:</span> <span class="string">"&lt;证书文件路径&gt;"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"certificateKeyFile"</span><span class="punctuation">:</span> <span class="string">"&lt;密钥文件路径&gt;"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"password"</span><span class="punctuation">:</span> <span class="string">"&lt;您的 Cachefly 密码&gt;"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"taskInterval"</span><span class="punctuation">:</span> <span class="number">7</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>token</code>：您需要前往 <a href="https://portal.cachefly.com/app/tokens" rel="external nofollow noreferrer">https://portal.cachefly.com/app/tokens</a> 获取 Cachefly Token，并将其填写在此处。</li><li><code>certificateFile</code> 和 <code>certificateKeyFile</code>：这两个字段应填入您本地 SSL 证书和密钥的文件路径。如果您使用宝塔面板自动签发证书，则签发地址通常在 <code>/www/server/panel/vhost/ssl/&lt;您的域名&gt;/</code> 下，其中公钥为 <code>fullchain.pem</code>，私钥为 <code>privkey.pem</code>。</li><li><code>password</code>：填入您的 Cachefly 密码，用于上传证书到 Cachefly。</li><li><code>taskInterval</code>：此字段定义了执行任务的间隔天数。例如，设置为 7 表示每隔 7 天执行一次上传任务。</li></ul><p><strong>注意：</strong> 请确保 <code>config.json</code> 文件的格式正确，否则工具将无法正常运行。</p><p>改好之后在项目文件夹下，运行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> &lt;可执行文件&gt;</span><br></pre></td></tr></tbody></table></figure><p>然后文件夹下会又一个 nohup.out 的文件，正常来说程序首次启动会运行一次ssl 证书上传。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;自从 &lt;code&gt;Cachefly&lt;/code&gt; 推出了&lt;a href=&quot;https://</summary>
      
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="go" scheme="https://blog.ning.moe/tags/go/"/>
    
    <category term="Cachefly" scheme="https://blog.ning.moe/tags/Cachefly/"/>
    
    <category term="SSL" scheme="https://blog.ning.moe/tags/SSL/"/>
    
    <category term="宝塔面板" scheme="https://blog.ning.moe/tags/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/"/>
    
    <category term="网络技术" scheme="https://blog.ning.moe/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    <category term="CloudFalre" scheme="https://blog.ning.moe/tags/CloudFalre/"/>
    
    <category term="写bug的小能手" scheme="https://blog.ning.moe/tags/%E5%86%99bug%E7%9A%84%E5%B0%8F%E8%83%BD%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Butterfly的SEO优化</title>
    <link href="https://blog.ning.moe/posts/hexo-butterfly-seo/"/>
    <id>https://blog.ning.moe/posts/hexo-butterfly-seo/</id>
    <published>2023-07-20T02:32:42.000Z</published>
    <updated>2024-03-12T16:32:13.695Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以前没有怎么优化过seo、站点地图、rss订阅链接、robots 文件，一个都没有写过，不过今年打算重启博客了，自然这些改加上的东西都需要加一下了。</p><p>前前后后半年多吧，陆陆续续的，把这些玩意补齐了，但看了很多文章都写的补全，我就只好在来全部整理一下了。</p><h1 id="一些插件"><a href="#一些插件" class="headerlink" title="一些插件"></a>一些插件</h1><ul><li><a href="https://github.com/hexojs/hexo-generator-sitemap" rel="external nofollow noreferrer">hexo-generator-sitemap</a> 构建网站地图 </li><li><a href="https://github.com/coneycode/hexo-generator-baidu-sitemap" rel="external nofollow noreferrer">hexo-generator-baidu-sitemap</a> 百度专用的（为什么百度这么有特权😔）</li><li><a href="https://github.com/cjh0613/hexo-submit-urls-to-search-engine" rel="external nofollow noreferrer">hexo-submit-urls-to-search-engine</a> 自动化提交文章给爬虫</li><li><a href="https://github.com/hexojs/hexo-generator-feed" rel="external nofollow noreferrer">hexo-generator-feed</a> 生成RSS订阅链接</li><li><a href="https://github.com/hexojs/hexo-filter-nofollow" rel="external nofollow noreferrer">hexo-filter-nofollow</a> 为合适的外链打上 <code>external nofollow noreferrer noopener</code> <ul><li>作用：<ul><li>防止搜索引擎追踪该链接，不会直接影响站点的排名。</li><li>阻止被链接的页面获取来源页面的信息，增加用户隐私保护。</li><li>防止被链接的页面通过 <code>window.opener</code> 访问和操纵打开它的页面，增强安全性。</li></ul></li></ul></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="添加robots-txt"><a href="#添加robots-txt" class="headerlink" title="添加robots.txt"></a>添加robots.txt</h2><p>可以直接在hexo 项目下的<code>source</code>添加<code>robots.txt</code></p><p>比如说我的配置，让百度爬虫抓取百度专属的网站地图，其他搜索引擎直接抓取普通的网站地图。</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">User-agent: Baiduspider</span><br><span class="line"></span><br><span class="line">Sitemap: https://blog.ning.moe/baidusitemap.xml</span><br><span class="line"></span><br><span class="line">User-agent: *</span><br><span class="line">Disallow:</span><br><span class="line"></span><br><span class="line">Sitemap: https://blog.ning.moe/sitemap.xml</span><br></pre></td></tr></tbody></table></figure><h1 id="插件的使用和配置"><a href="#插件的使用和配置" class="headerlink" title="插件的使用和配置"></a>插件的使用和配置</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>上述所有的插件的安装命令都类似 <code>npm install &lt;插件名字&gt; --save</code> 例如</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></tbody></table></figure><p>但就百度地图的插件稍微特殊：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap@0.1.4 --save</span><br></pre></td></tr></tbody></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>至于配置可以访问GitHub的插件仓库地址，readme 会告诉你们这么配置，如果你很懒的话，我这边放上我的配置。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置网站地图</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line">  <span class="comment"># 配置百度专属地图（真臭不要脸）</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="string">hexo-generator-feed</span></span><br><span class="line"><span class="comment">#Feed Atom</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line"><span class="comment"># 为网站使用到的所有外链添加rel="noopener external nofollow noreferrer", 可以有效地加强网站SEO和防止权重流失</span></span><br><span class="line"><span class="comment"># field 是指定那些页面我指定的post 是所有文章全部启用，如果你想启动全站都屏蔽链接的话就是 site，如果你有友联的话慎用。</span></span><br><span class="line"><span class="comment">#exclude是放行这些域名下的。</span></span><br><span class="line"><span class="attr">nofollow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'*.misaka.pics'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'icp.gov.moe'</span></span><br></pre></td></tr></tbody></table></figure><p>但 <code>hexo-submit-urls-to-search-engine</code> 稍微有些特殊(我更倾向于你先去看看原来的教程)，建议在操作之前备份一下  <code>_config.yaml</code> ，请确保你的推送分支为你自己的分支<code>deploy</code>,当然这边也有一个bug就是在推送的是我这边是选择了main 作为我的主分支，但是推送过去的时候还是<code>master</code> 如果你遇到和我一样的问题建议去提出<code>issues</code>，还有一个就是bing 的推送貌似是坏掉的状态，但百度正常。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-submit-urls-to-search-engine 主动将 url 提交到 Google Bing Baidu 搜索</span></span><br><span class="line"><span class="attr">hexo_submit_urls_to_search_engine:</span></span><br><span class="line">  <span class="attr">submit_condition:</span> <span class="string">count</span> <span class="comment">#链接被提交的条件，可选值：count | period 现仅支持count</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">10</span> <span class="comment"># 提交最新的10个链接</span></span><br><span class="line">  <span class="attr">period:</span> <span class="number">900</span> <span class="comment"># 提交修改时间在 900 秒内的链接</span></span><br><span class="line">  <span class="attr">google:</span> <span class="number">0</span> <span class="comment"># 是否向Google提交，可选值：1 | 0（0：否；1：是）</span></span><br><span class="line">  <span class="attr">bing:</span> <span class="number">1</span> <span class="comment"># 是否向bing提交，可选值：1 | 0（0：否；1：是）</span></span><br><span class="line">  <span class="attr">baidu:</span> <span class="number">1</span> <span class="comment"># 是否向baidu提交，可选值：1 | 0（0：否；1：是）</span></span><br><span class="line">  <span class="attr">txt_path:</span> <span class="string">submit_urls.txt</span> <span class="comment">## 文本文档名， 需要推送的链接会保存在此文本文档里</span></span><br><span class="line">  <span class="attr">baidu_host:</span> <span class="string">https://blog.ning.moe</span> <span class="comment">## 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">baidu_token:</span> <span class="string">&lt;Token&gt;</span> <span class="comment">## 请注意这是您的秘钥， 所以请不要把它直接发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">bing_host:</span> <span class="string">https://blog.ning.moe</span> <span class="comment">## 在bing站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">bing_token:</span> <span class="string">&lt;Token&gt;</span> <span class="comment">## 请注意这是您的秘钥， 所以请不要把它直接发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">google_host:</span> <span class="string">https://blog.ning.moe</span> <span class="comment">## 在google站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">google_key_file:</span> <span class="string">Project.json</span> <span class="comment">#存放google key的json文件，放于网站根目录（与hexo _config.yml文件位置相同），请不要把json文件内容直接发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">google_proxy:</span> <span class="string">http://127.0.0.1:7890</span> <span class="comment"># 向谷歌提交网址所使用的系统 http 代理，填 0 不使用</span></span><br><span class="line">  <span class="attr">replace:</span> <span class="number">0</span>  <span class="comment"># 是否替换链接中的部分字符串，可选值：1 | 0（0：否；1：是）</span></span><br><span class="line">  <span class="comment"># find_what: http://cjh0613.github.io/blog</span></span><br><span class="line">  <span class="comment"># replace_with: https://cjh0613.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送git的配置</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> </span><br><span class="line">    <span class="attr">coding:</span> <span class="string">https://github.com/biliblihuorong/biliblihuorong.github.io.git</span> <span class="comment"># 你的仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span> </span><br><span class="line">  </span><br><span class="line">  <span class="comment"># hexo-submit-urls-to-search-engine 添加本插件的配置项：</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">cjh_google_url_submitter</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">cjh_bing_url_submitter</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">cjh_baidu_url_submitter</span></span><br></pre></td></tr></tbody></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>hexo-filter-nofollow：<a href="https://github.com/hexojs/hexo-filter-nofollow" rel="external nofollow noreferrer">https://github.com/hexojs/hexo-filter-nofollow</a></p><p>hexo-generator-feed：<a href="https://github.com/hexojs/hexo-generator-feed" rel="external nofollow noreferrer">https://github.com/hexojs/hexo-generator-feed</a></p><p>hexo-submit-urls-to-search-engine：<a href="https://github.com/cjh0613/hexo-submit-urls-to-search-engine" rel="external nofollow noreferrer">https://github.com/cjh0613/hexo-submit-urls-to-search-engine</a></p><p>hexo-generator-baidu-sitemap：<a href="https://github.com/coneycode/hexo-generator-baidu-sitemap" rel="external nofollow noreferrer">https://github.com/coneycode/hexo-generator-baidu-sitemap</a></p><p>hexo-generator-sitemap：<a href="https://github.com/hexojs/hexo-generator-sitemap" rel="external nofollow noreferrer">https://github.com/hexojs/hexo-generator-sitemap</a></p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以前没有怎么优化过seo、站点地图、rss订阅链接、robots 文件，一个都没有写过，不</summary>
      
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="hexo" scheme="https://blog.ning.moe/tags/hexo/"/>
    
    <category term="butterfly" scheme="https://blog.ning.moe/tags/butterfly/"/>
    
    <category term="SEO" scheme="https://blog.ning.moe/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>解决Umami v2.3升级问题，Something went wrong.</title>
    <link href="https://blog.ning.moe/posts/Umami-fix/"/>
    <id>https://blog.ning.moe/posts/Umami-fix/</id>
    <published>2023-07-19T11:13:18.000Z</published>
    <updated>2024-04-09T15:47:45.837Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>是的没错，发生这样的事情，应该很多<code>Umami</code>只要是v2.2版本应该都遇到了。 </p><p><img src="https://img.misaka.pics/ShellBlogImg/1/2023/07/19/64b7cb785693f.webp" alt="Umami v2.2 Something went wrong."></p><p>我浏览了部分 <code>issues</code> 只能升级到v2.3版本了。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>我先说一下我自己的环境，我自己的使用：</p><ol><li>属于编译安装，没有放在docker</li><li>Mysql 5.7</li><li>nodjs 18.16.0</li><li>npm 9.5.1</li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>解决办法有两种，第一种你可以直接尝试升级到<code>MySQL</code> 8.0，如果你想继续和我一样，小鸡的配置不行还想用5.7，请继续往下看。</p><p>如果你是和我一样都是<code>Mysql</code> 5.7版本，你需要查看这篇 <a href="https://github.com/umami-software/umami/issues/2118" rel="external nofollow noreferrer">issues</a> 或者继续往下看。</p><ol><li>你需要从GitHub 拉去一份最新的<a href="https://github.com/umami-software/umami/releases" rel="external nofollow noreferrer">Umami</a> 的代码，你需要找到<code>db/mysql/migrations/02_report_schema_session_data</code>文件夹下的<code>migration.sql</code>这份sql文件，将下面的代码替换和保存。</li></ol><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `event_data` CHANGE `event_data_type` `data_type` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `event_data` CHANGE `event_date_value` `date_value` <span class="type">timestamp</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `event_data` CHANGE `event_id` `event_data_id` <span class="type">varchar</span>(<span class="number">36</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `event_data` CHANGE `event_numeric_value` `number_value` <span class="type">decimal</span>(<span class="number">19</span>, <span class="number">4</span>) <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `event_data` CHANGE `event_string_value` `string_value`<span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">NULL</span>;</span><br></pre></td></tr></tbody></table></figure><p>终于我遇到的问题，你需要备份原来的 <code>Umami</code> 数据库，然后创建一个新的数据库，讲数据源配置在<code>.env</code>里面，不然通过初始化数据库。</p><ol start="2"><li><p>然后你需要在终端中运行这段命令<code>npx prisma migrate resolve --rolled-back "02_report_schema_session_data"</code></p></li><li><p>重新部署，请看 <a href="https://umami.is/docs/install" rel="external nofollow noreferrer">https://umami.is/docs/install</a></p></li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>Umami 的GitHub issues ：<a href="https://github.com/umami-software/umami/issues/2118" rel="external nofollow noreferrer">https://github.com/umami-software/umami/issues/2118</a></p></body></html>]]></content>
    
    
    <summary type="html">这篇文章介绍了解决升级Umami v2.3版本时可能遇到的问题：“Something went wrong.”作者指出，这个问题在Umami v2.2版本中很常见，但通过升级到v2.3版本可以解决。文章列出了作者的环境和解决办法：升级到MySQL 8.0或者对于MySQL 5.7版本，需要手动修改数据库迁移文件，并执行数据库迁移操作。最后，作者提供了Umami的GitHub issues链接作为参考。这篇文章适合Umami用户遇到类似问题的解决参考。</summary>
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="MySql" scheme="https://blog.ning.moe/tags/MySql/"/>
    
    <category term="Umami" scheme="https://blog.ning.moe/tags/Umami/"/>
    
    <category term="PV" scheme="https://blog.ning.moe/tags/PV/"/>
    
    <category term="网站统计，UV" scheme="https://blog.ning.moe/tags/%E7%BD%91%E7%AB%99%E7%BB%9F%E8%AE%A1%EF%BC%8CUV/"/>
    
    <category term="Ip" scheme="https://blog.ning.moe/tags/Ip/"/>
    
  </entry>
  
  <entry>
    <title>换域名了！！</title>
    <link href="https://blog.ning.moe/posts/moe/"/>
    <id>https://blog.ning.moe/posts/moe/</id>
    <published>2023-07-12T23:40:05.000Z</published>
    <updated>2024-03-12T16:32:13.695Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><blockquote><p>换域名了正好可以来水一篇文章了。</p></blockquote><p>对于域名对于网站来说，很是重要的一部分了，但是我创建博客的时候，对于域名而言起什么，一直很苦恼，然后就给自己起了一个c-dreamer 的域，但是后来慢慢用下来，域名太长了而且也不方便记忆，就四处寻找这域名。</p><p><code>ning.moe</code> 这个域名其实我想给我的朋友的，他的网名就是 <code>lemon</code> 但他自己也不会建站 ，对建站没有任何想法，所以这个个域名就纳入我的手里吧。</p><h1 id="moe-的意义？"><a href="#moe-的意义？" class="headerlink" title="moe 的意义？"></a>moe 的意义？</h1><p>对于我而言正好可以组成 拼音的 <code>柠檬</code> 对于域名本身？ </p><p>看看wiki？：<a href="https://zh.moegirl.org.cn/.moe" rel="external nofollow noreferrer">https://zh.moegirl.org.cn/.moe</a></p><p>当然悄悄告诉你，貌似有一个虚拟的国度叫做 <code>gov.moe</code></p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;blockquote&gt;
&lt;p&gt;换域名了正好可以来水一篇文章了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于域名对于网站来说，很是重要的一部分了，但是我创建博客的时候，对于域名而言起什么，一直很苦恼，然后就给自己起了一个c-d</summary>
      
    
    
    
    <category term="生活随想" scheme="https://blog.ning.moe/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="moe" scheme="https://blog.ning.moe/tags/moe/"/>
    
    <category term="域名" scheme="https://blog.ning.moe/tags/%E5%9F%9F%E5%90%8D/"/>
    
    <category term="柠檬" scheme="https://blog.ning.moe/tags/%E6%9F%A0%E6%AA%AC/"/>
    
  </entry>
  
  <entry>
    <title>兰空图床使用backblaze作为存储策略</title>
    <link href="https://blog.ning.moe/posts/lskypro-backblaze/"/>
    <id>https://blog.ning.moe/posts/lskypro-backblaze/</id>
    <published>2023-06-18T09:55:47.000Z</published>
    <updated>2024-04-14T11:48:01.447Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>因为我很久之前就在使用兰空了，当时是直接默认存储扔到本地的，反正也没有啥问题，还很方便，但那台服务器快到期了。所以我就打算迁移，先来说说虽然为什么不用CF的R2存储，原因是我尝试了很多种办法，但这个兰空图床对于我自己而言就是链接不上，很烦人，所以找到了也是S3协议的<code>backblaze</code>作为我后面使用的存储策略。</p><h1 id="为什么要使用-backblaze"><a href="#为什么要使用-backblaze" class="headerlink" title="为什么要使用 backblaze"></a>为什么要使用 backblaze</h1><p>有以下几点</p><ol><li>所有用户无需信用卡都有10gb存储</li><li>从<code>CloudFlare</code>出去的流量每个月免费1TB</li><li>价格十分便宜，你可以去他们的官网了解更多：<a href="https://www.backblaze.com/b2/cloud-storage-pricing.html" rel="external nofollow noreferrer">官网地址价格</a></li></ol><h1 id="开始准备前"><a href="#开始准备前" class="headerlink" title="开始准备前"></a>开始准备前</h1><p>在开始之前你需要知道和准备的东西：</p><ol><li> 兰空图床的版本确保是和我在同一个版本在V2.1</li><li>有一个<code>Cloud Flare</code>的账号</li><li>有一个<code>backblaze</code>的账号</li><li>你需要有一个域名（应该看到这一篇博文的人都有吧）</li><li>在后面的内容<code>CloudFlare</code> 将被简写成CF</li><li>在后面的内容<code>backblaze</code>将被简写成B2</li></ol><h1 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h1><h2 id="B2创建存储桶"><a href="#B2创建存储桶" class="headerlink" title="B2创建存储桶"></a>B2创建存储桶</h2><p>请访问：<a href="https://secure.backblaze.com/b2_buckets.htm" rel="external nofollow noreferrer">https://secure.backblaze.com/b2_buckets.htm</a> 进入B2创建页面。再此页面往下翻，可以更改语言。</p><p>起一个你的桶的名字，你需要把桶的档案改成<code>公众</code>。</p><p><img src="https://img.c-dreamer.top/ShellBlogImg/1/2023/06/18/648edb4430902.webp"></p><p>很好你现在应该已经创建好桶了并选择<code>上传/下载</code></p><p><img src="https://img.c-dreamer.top/ShellBlogImg/1/2023/06/18/648edbb7f1ea5.webp"></p><p>你需要上传一个文件用作与测试，知道你的桶的地址。</p><p><img src="https://img.c-dreamer.top/ShellBlogImg/1/2023/06/18/648edc77d6fda.webp"></p><p>你需要记得<code>友好地址</code>以及<code>S3</code>地址</p><ul><li>友好地址你需要记住到你的桶名</li><li>S3 地址你只需要记住S3的域名即可。</li></ul><h2 id="CF的配置"><a href="#CF的配置" class="headerlink" title="CF的配置"></a>CF的配置</h2><blockquote><p>B2只允许https，并且需要有效证书的验证，你需要检查以下你的CF上的 SSL/TLS –&gt; 概述调成完全严格</p></blockquote><p>你现在需要解析一个<code>CNAME</code>的域名,例如img.example.com,解析到友好URL的域名上，如果你解析成功你可以试着访问你的域名并带上桶名/以及文件名进行访问。</p><p>到这里你应该也许已经明白我们需要后面要配置什么了，我们需要使用CF的    规则–&gt;转换规则—&gt;URi 重写。</p><p><img src="https://img.c-dreamer.top/ShellBlogImg/1/2023/06/18/648ede10f0886.webp"></p><p>我这边提供一下表达式，需要把<code>&lt;&gt;</code>的内容替换成你自己的包括<code>&lt;&gt;</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(http.<span class="property">request</span>.<span class="property">uri</span>.<span class="property">path</span> ne <span class="string">"/file/&lt;桶名&gt;"</span> and http.<span class="property">host</span> eq <span class="string">"&lt;你的域名&gt;"</span>)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img.c-dreamer.top/ShellBlogImg/1/2023/06/18/648edeb220412.webp"></p><p>这里提供一些Dynamic的表达式写法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">concat</span>(<span class="string">"/file/&lt;你的桶名&gt;"</span>,http.<span class="property">request</span>.<span class="property">uri</span>.<span class="property">path</span>)</span><br></pre></td></tr></tbody></table></figure><p>经过这样一改，你可以现在尝试以下，不加任何东西直接使用域名+上文件名再试试。</p><h2 id="兰空图床更改策略"><a href="#兰空图床更改策略" class="headerlink" title="兰空图床更改策略"></a>兰空图床更改策略</h2><p>你可以参考这一篇官方的 <a href="https://github.com/lsky-org/lsky-pro/discussions/448" rel="external nofollow noreferrer">discussions</a> 进行改写，我就不再重复造轮子了。</p><p>我在这边贴一张我自己配置的图，方便各位佬进行参考。</p><ul><li>存储策略选择Minio</li><li>区域根据S3的URL 域名中就有写。</li></ul><p><img src="https://img.c-dreamer.top/ShellBlogImg/1/2023/06/18/648ee05d47c3b.webp"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p> 兰空Github Discussions：<a href="https://github.com/lsky-org/lsky-pro/discussions/448" rel="external nofollow noreferrer">https://github.com/lsky-org/lsky-pro/discussions/448</a></p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢 <a href="https://yuan.moe/">YanMOE站长</a> 发现本篇文章的错误。（已经修改）</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;因为我很久之前就在使用兰空了，当时是直接默认存储扔到本地的，反正也没有啥问题，还很方便，但</summary>
      
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="lskypro" scheme="https://blog.ning.moe/tags/lskypro/"/>
    
    <category term="蓝空图床" scheme="https://blog.ning.moe/tags/%E8%93%9D%E7%A9%BA%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="兰空图床" scheme="https://blog.ning.moe/tags/%E5%85%B0%E7%A9%BA%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="backblaze" scheme="https://blog.ning.moe/tags/backblaze/"/>
    
    <category term="butterfly" scheme="https://blog.ning.moe/tags/butterfly/"/>
    
  </entry>
  
  <entry>
    <title>解决Hexo博客框架中Twikoo评论框架路径不一致的问题</title>
    <link href="https://blog.ning.moe/posts/fix-hexo-twikoocomment-path-inconsistency/"/>
    <id>https://blog.ning.moe/posts/fix-hexo-twikoocomment-path-inconsistency/</id>
    <published>2023-06-10T11:37:29.000Z</published>
    <updated>2024-03-12T16:32:13.693Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>引言：</p><p>在我继续修理博客的过程中，没错，你没有看错，我陆续从今年1月开始维护博客至今。主要原因是我很忙，维护工作也需要时间，而且在修复之后还需要处理一些细节问题，这是我之前没有注意到的。由于当时静态资源几乎全部丢失，现在我已经基本上优化了访问速度，这使得我的Hexo博客框架名副其实。随着我对网站的打理以及撰写一些有用的内容，网站的访问量逐渐提升。然而，我注意到了一些之前未曾注意到的问题。在Hexo博客生成过程中存在一个问题，你可以访问这篇文章的链接<code>https://blog.ning.moe/post/fix-hexo-twikoocomment-path-inconsistency/</code>，也可以在该链接后面添加<code>index.html</code>，但对于Twikoo评论框架而言，这两个链接并不相同。</p><p>阅读须知：</p><p>本文的操作是在使用”butterfly”主题的情况下进行的，其他主题也可以模仿这个操作，但需要注意先查找自己的主题是否可以直接在配置文件中进行更改。更多细节请参考这个”issues”链接：<a href="https://github.com/imaegoo/twikoo/issues/138%E3%80%82" rel="external nofollow noreferrer">https://github.com/imaegoo/twikoo/issues/138。</a></p><p>正文：</p><blockquote><p>下面我将直接进入正文。</p></blockquote><h2 id="Butterfly的问题"><a href="#Butterfly的问题" class="headerlink" title="Butterfly的问题"></a>Butterfly的问题</h2><p>我的博客主题是<a href="https://github.com/jerryc127/hexo-theme-butterfly" rel="external nofollow noreferrer">butterfly</a>，本身已经对Twikoo进行了适配。但我不好意思提出”issues”来更改它，因为我通过搜索找到了Twikoo官方的一个”issues”：<a href="https://github.com/imaegoo/twikoo/issues/138" rel="external nofollow noreferrer">里面作者已经回复了</a>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">twikoo.<span class="title function_">init</span>({</span><br><span class="line">  <span class="comment">// ......,</span></span><br><span class="line">  <span class="attr">path</span>: <span class="string">'window.location.pathname.replace(\'index.html\',\'\')'</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>但问题是，Butterfly主题本身没有额外的选项来配置Twikoo，所以我决定直接修改主题的源码。</p><h2 id="更改主题模板"><a href="#更改主题模板" class="headerlink" title="更改主题模板"></a>更改主题模板</h2><p>首先，确保你找到了Butterfly主题的文件夹，它的目录结构应该是这样的：</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├─.github</span><br><span class="line">├─languages</span><br><span class="line">├─layout</span><br><span class="line">├─scripts</span><br><span class="line">└─source</span><br></pre></td></tr></tbody></table></figure><p>然后，找到<code>/layout/includes/third-party/comments/twikoo.pug</code>这个文件。</p><p>在大约第11行的位置添加以下代码：<code>path: window.location.pathname.replace('index.html','')</code>，下面是我已经添加好的代码：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">script.</span><br><span class="line">  (<span class="function">()=&gt;</span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">init</span> = (<span class="params"></span>) =&gt; {</span><br><span class="line">      twikoo.<span class="title function_">init</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>({</span><br><span class="line">        <span class="attr">el</span>: <span class="string">'#twikoo-wrap'</span>,</span><br><span class="line">        <span class="attr">envId</span>: <span class="string">'!{envId}'</span>,</span><br><span class="line">        <span class="attr">region</span>: <span class="string">'!{region}'</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>.<span class="title function_">replace</span>(<span class="string">'index.html'</span>,<span class="string">''</span>),</span><br><span class="line">        <span class="attr">onCommentLoaded</span>: <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">          btf.<span class="title function_">loadLightbox</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">'#twikoo .tk-content img:not(.tk-owo-emotion)'</span>))</span><br><span class="line">        }</span><br><span class="line">      }, !{<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(option)}))</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>引用：</p><p>Twikoo的”issues”链接：<a href="https://github.com/imaegoo/twikoo/issues/138" rel="external nofollow noreferrer">https://github.com/imaegoo/twikoo/issues/138</a></p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;引言：&lt;/p&gt;
&lt;p&gt;在我继续修理博客的过程中，没错，你没有看错，我陆续从今年1月开始维护博客至今。主要原因是我很忙，维护工作也需要时间，而且在修复之后还需要处理一些细节问题，这是我之前没有注意到的。由于当时静态资源几乎全部</summary>
      
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="hexo" scheme="https://blog.ning.moe/tags/hexo/"/>
    
    <category term="butterfly" scheme="https://blog.ning.moe/tags/butterfly/"/>
    
    <category term="twikoo" scheme="https://blog.ning.moe/tags/twikoo/"/>
    
    <category term="评论" scheme="https://blog.ning.moe/tags/%E8%AF%84%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>使用GitHub Actions 自动构建部署发布Spring Boot应用</title>
    <link href="https://blog.ning.moe/posts/gitub-actions/"/>
    <id>https://blog.ning.moe/posts/gitub-actions/</id>
    <published>2023-05-23T01:59:56.000Z</published>
    <updated>2024-03-12T16:32:13.694Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近这一周，我加入了奇奇怪怪的Team，我负责将编写的新接口打包并发布到服务器上。每次都需要手动执行打包、发布、关闭旧版本程序和启动新版本程序等繁琐的步骤，这让我感到非常不便，而且也非常重复。对于这种重复性的任务，我想到了可以利用机器来完成，于是决定尝试使用 GitHub 上的工作流。</p><h1 id="需要准备的东西："><a href="#需要准备的东西：" class="headerlink" title="需要准备的东西："></a>需要准备的东西：</h1><ul><li>掌握搜索引擎技能（保证一直是最新的知识。）</li><li>一个大脑🧠</li><li>一个GitHub的账号（）</li><li>掌握基础的git 操作</li><li>你需要掌握一门语言例如 Java nodejs等这样才可以使用工作流</li></ul><p>本篇就那我自己写的屎山 Spring Boot应用举例子吧</p><h1 id="什么是Gitub-Actions？"><a href="#什么是Gitub-Actions？" class="headerlink" title="什么是Gitub-Actions？"></a>什么是Gitub-Actions？</h1><p>GitHub Actions是自动化工作流程工具，用于自动化构建、测试、部署和集成软件项目。它通过一系列事件、触发器和任务来执行各种操作，以实现持续集成和持续交付。</p><p>GitHub允许你可以发布以及共享你自己的Actions，别人可以通过市场找到你的Actions从而不需要在重复造轮子了。</p><h1 id="什么是CI-CD？"><a href="#什么是CI-CD？" class="headerlink" title="什么是CI/CD？"></a>什么是CI/CD？</h1><p>CI/CD是持续集成（Continuous Integration）与持续交付/持续部署（Continuous Delivery/Continuous Deployment）的缩写，是一种软件开发实践和方法论。</p><p>持续集成（CI）是指开发人员将其代码频繁地集成到共享代码存储库中，并通过自动化构建和测试流程来验证代码的正确性。这样可以确保团队成员的代码变更能够快速地集成到主干代码中，并减少代码集成过程中的错误。</p><p>持续交付（CD）是指将通过持续集成产生的软件交付给质量保证团队进行进一步的自动化测试、部署和发布。持续交付的目标是确保软件始终处于可部署状态，以便可以随时交付给用户。</p><p>持续部署（CD）是持续交付的进一步延伸，指将通过持续交付阶段产生的可部署软件自动地部署到生产环境中，使软件能够快速地、可靠地投入使用。</p><p>通过采用CI/CD实践，团队可以实现更快速、可靠、高质量的软件交付。自动化的构建、测试、部署和发布流程能够减少人为错误，提高开发团队的生产效率，并使软件交付过程更加可靠和可追踪。</p><blockquote><p>以上文本来自chatGPT。</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Actions的概念："><a href="#Actions的概念：" class="headerlink" title="Actions的概念："></a>Actions的概念：</h2><ul><li><strong><code>workflow</code> （工作流）：一个工作流程是一系列的任务（jobs）和步骤（steps），定义了自动化的过程。</strong></li><li><strong>Job（任务）</strong>：一个工作流程可以包含一个或多个任务，每个任务运行在独立的环境中。每个任务可以包含一系列的步骤，可以并行或顺序执行。</li><li><strong>Step（步骤）</strong>：每个任务包含一个或多个步骤，每个步骤代表一个操作，例如构建代码、运行测试、部署应用程序等。步骤是工作流程的最小单位。</li><li><strong>Workflow file（工作流程文件）</strong>：工作流程文件是以YAML格式编写的文件，用于定义工作流程的结构、任务和步骤。通常存储在代码仓库的特定目录中（如**<code>.github/workflows</code>**）。</li></ul><p>差不多主要使用的也就这些了。</p><h2 id="Workflow-file（工作流程文件）"><a href="#Workflow-file（工作流程文件）" class="headerlink" title="Workflow file（工作流程文件）"></a><strong>Workflow file（工作流程文件）</strong></h2><p>对于**<code>Workflow file</code>** 的，关键字非常多我这边放GitHub的<a href="https://docs.github.com/zh/actions/using-workflows/workflow-syntax-for-github-actions" rel="external nofollow noreferrer">文档地址</a>，有需要的可以自己看看吧，**<code>Workflow file</code>** 使用<code>yaml</code> 文件类型编写。</p><p>一下是常见的关键字。</p><ul><li>name ：一般是和你的 <strong><code>Workflow file</code></strong> 文件字一样，改成其他的和省略也没啥事情。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: Build and Publish Release</span><br></pre></td></tr></tbody></table></figure><ul><li>on :指定触发条件，例如 push frok等，例如我这里设置的是push 的检测分支中的 master 分支。</li></ul><p>`on: push: branches:</p><ul><li>master`</li><li>jobs ：工作流运行由一个或多个 <code>jobs</code> 组成，默认情况下并行运行。 若要按顺序运行作业，可以使用 <code>jobs.&lt;job_id&gt;.needs</code> 关键字定义对其他作业的依赖关系。</li></ul><h2 id="例如我写的"><a href="#例如我写的" class="headerlink" title="例如我写的"></a>例如我写的</h2><p><a href="https://github.com/biliblihuorong/Bicarbon-MES" rel="external nofollow noreferrer">我的仓库</a></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Publish</span> <span class="string">Release</span>  <span class="comment"># 工作流名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span>  <span class="comment"># 当代码推送到master分支时触发工作流程</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-publish:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span>  <span class="comment"># 在最新的Ubuntu操作系统上运行任务</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span>  <span class="comment"># 使用GitHub官方的checkout action，用于检出代码库</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span>  <span class="comment"># 设置JDK</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-java@master</span>  <span class="comment"># 使用GitHub官方的setup-java action，用于安装和配置Java环境</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">java-version:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">distribution:</span> <span class="string">"adopt"</span></span><br><span class="line">          <span class="attr">cache:</span> <span class="string">maven</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Maven</span>  <span class="comment"># 使用Maven构建项目</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">mvn</span> <span class="string">package</span> <span class="string">--batch-mode</span>  <span class="comment"># 执行mvn package命令进行项目构建</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">Release</span>  <span class="comment"># 创建GitHub Release</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">create_release</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/create-release@v1</span>  <span class="comment"># 使用GitHub官方的create-release action，用于创建GitHub Release</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">${{</span> <span class="string">secrets.TOKEN</span> <span class="string">}}</span>  <span class="comment"># 设置GitHub令牌作为环境变量</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">tag_name:</span> <span class="string">Release-${{</span> <span class="string">github.run_number</span> <span class="string">}}</span>  <span class="comment"># 设置Release的标签名称</span></span><br><span class="line">          <span class="attr">release_name:</span> <span class="string">Release</span> <span class="string">${{</span> <span class="string">github.run_number</span> <span class="string">}}</span>  <span class="comment"># 设置Release的名称</span></span><br><span class="line">          <span class="attr">draft:</span> <span class="literal">false</span>  <span class="comment"># 是否是草稿状态</span></span><br><span class="line">          <span class="attr">prerelease:</span> <span class="literal">false</span>  <span class="comment"># 是否是预发布状态</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">List</span> <span class="string">files</span>  <span class="comment"># 列出文件</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">ls</span> <span class="string">-R</span>  <span class="comment"># 执行ls -R命令，列出工作目录下的文件和子目录</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Display</span> <span class="string">directory</span> <span class="string">tree</span>  <span class="comment"># 显示目录树</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">tree</span>  <span class="comment"># 执行tree命令，以树状结构显示工作目录的内容</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Release</span> <span class="string">JAR</span>  <span class="comment"># 发布JAR文件</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">upload_jar</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/upload-release-asset@v1</span>  <span class="comment"># 使用GitHub官方的upload-release-asset action，用于上传Release的附件</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">${{</span> <span class="string">secrets.TOKEN</span> <span class="string">}}</span>  <span class="comment"># 设置GitHub令牌作为环境变量</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">upload_url:</span> <span class="string">${{</span> <span class="string">steps.create_release.outputs.upload_url</span> <span class="string">}}</span>  <span class="comment"># 设置上传URL</span></span><br><span class="line">          <span class="attr">asset_path:</span> <span class="string">./controller/target/controller-1.0.jar</span>  <span class="comment"># 设置要上传的JAR文件路径</span></span><br><span class="line">          <span class="attr">asset_name:</span> <span class="string">controller-jar</span>  <span class="comment"># 设置JAR文件的名称</span></span><br><span class="line">          <span class="attr">asset_content_type:</span> <span class="string">application/java-archive</span>  <span class="comment"># 设置JAR文件的内容类型</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rm</span> <span class="string">Jar</span>  <span class="comment"># 删除JAR文件</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span>  <span class="comment"># 使用appleboy的ssh-action，用于在服务器上执行SSH命令</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">${{</span> <span class="string">secrets.SERVER_HOST</span> <span class="string">}}</span>  <span class="comment"># 设置服务器主机</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">${{</span> <span class="string">secrets.SERVER_USERNAME</span> <span class="string">}}</span>  <span class="comment"># 设置服务器用户名</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">${{</span> <span class="string">secrets.SSH_KEY</span> <span class="string">}}</span>  <span class="comment"># 设置SSH密钥</span></span><br><span class="line">          <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">           bash ${{secrets.SERVER_SHFILE}}/SpringBootStart-guosai.sh</span></span><br><span class="line"><span class="string">           cd /${{secrets.SERVER_FILE}}/controller/target/</span></span><br><span class="line"><span class="string">           rm -rf controller-1.0.jar</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">upload</span> <span class="string">jar</span>  <span class="comment"># 上传JAR文件到服务器</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/scp-action@master</span>  <span class="comment"># 使用appleboy的scp-action，用于将文件复制到远程服务器</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">${{</span> <span class="string">secrets.SERVER_HOST</span> <span class="string">}}</span>  <span class="comment"># 设置服务器主机</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">${{</span> <span class="string">secrets.SERVER_USERNAME</span> <span class="string">}}</span>  <span class="comment"># 设置服务器用户名</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">${{</span> <span class="string">secrets.SSH_KEY</span> <span class="string">}}</span>  <span class="comment"># 设置SSH密钥</span></span><br><span class="line">          <span class="attr">source:</span> <span class="string">./controller/target/controller-1.0.jar</span>  <span class="comment"># 设置本地要上传的JAR文件路径</span></span><br><span class="line">          <span class="attr">target:</span> <span class="string">${{secrets.SERVER_FILE}}/</span>  <span class="comment"># 设置远程服务器上的目标路径</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Execute</span> <span class="string">shell</span> <span class="string">scripts</span> <span class="string">on</span> <span class="string">server</span>  <span class="comment"># 在服务器上执行shell脚本</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span>  <span class="comment"># 使用appleboy的ssh-action，用于在服务器上执行SSH命令</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">${{</span> <span class="string">secrets.SERVER_HOST</span> <span class="string">}}</span>  <span class="comment"># 设置服务器主机</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">${{</span> <span class="string">secrets.SERVER_USERNAME</span> <span class="string">}}</span>  <span class="comment"># 设置服务器用户名</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">${{</span> <span class="string">secrets.SSH_KEY</span> <span class="string">}}</span>  <span class="comment"># 设置SSH密钥</span></span><br><span class="line">          <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">           cd /${{secrets.SERVER_FILE}}/controller/target/</span></span><br><span class="line"><span class="string">            ps -ef | grep controller-1.0.jar | grep -v grep | awk '{print $2}' | xargs kill -9 </span></span><br><span class="line"><span class="string">            nohup java -jar controller-1.0.jar &gt; nohup.out &amp;</span></span><br><span class="line"><span class="string">            exit</span></span><br></pre></td></tr></tbody></table></figure><p>上面的</p><ul><li>SERVER_FILE</li><li>SERVER_HOST</li><li>SERVER_USERNAME</li><li>SSH_KEY</li><li>TOKEN</li></ul><p>其中 这些都在仓库设置的机密设置进行设置，你也可以自己按需修改名字。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>我自己的GitHub 仓库：<a href="https://github.com/biliblihuorong/Bicarbon-MES" rel="external nofollow noreferrer">https://github.com/biliblihuorong/Bicarbon-MES</a></p><p>GitHub Actions官方文档：<a href="https://docs.github.com/zh/actions/using-workflows/workflow-syntax-for-github-actions" rel="external nofollow noreferrer">https://docs.github.com/zh/actions/using-workflows/workflow-syntax-for-github-actions</a></p><p>阮一峰大佬的 GitHub Actions 博文：<a href="https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" rel="external nofollow noreferrer">https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a></p><p>以及Chat GPT的大力协助。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近这一周，我加入了奇奇怪怪的Team，我负责将编写的新接口打包并发布到服务器上。每次都需</summary>
      
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="github" scheme="https://blog.ning.moe/tags/github/"/>
    
    <category term="devOps" scheme="https://blog.ning.moe/tags/devOps/"/>
    
    <category term="Actions" scheme="https://blog.ning.moe/tags/Actions/"/>
    
    <category term="SpringBoot" scheme="https://blog.ning.moe/tags/SpringBoot/"/>
    
    <category term="java" scheme="https://blog.ning.moe/tags/java/"/>
    
    <category term="ci/cd" scheme="https://blog.ning.moe/tags/ci-cd/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的管理你的密码</title>
    <link href="https://blog.ning.moe/posts/bitwarden/"/>
    <id>https://blog.ning.moe/posts/bitwarden/</id>
    <published>2023-05-09T01:55:31.000Z</published>
    <updated>2024-03-12T16:32:13.692Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><blockquote><p>本教程是搭建和使用一体的，如果您只是想看如何使用，请直接通过页面的大纲快速跳转。</p></blockquote><h1 id="过期提醒"><a href="#过期提醒" class="headerlink" title="过期提醒"></a>过期提醒</h1><p>本文章部分内容已经过期，在<a href="#%E5%90%AF%E5%8A%A8%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87">启动前的准备</a> 无需在设置websocket 的端口配置。</p><p>详情请跳转到 <a href="https://github.com/dani-garcia/vaultwarden/releases/tag/1.30.0" rel="external nofollow noreferrer">1.30.0 的 releases 介绍</a> 。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="统一密码？"><a href="#统一密码？" class="headerlink" title="统一密码？"></a>统一密码？</h3><p>可能你对于密码而言，是统一一个密码走天下，这不好也很不安全，虽然现在有点良心的互联网公司不会把你的密码进行md5加密，而是使用其他的加密算法，会生成不一样的密文，但还是不安全。</p><h3 id="密码杂乱无章"><a href="#密码杂乱无章" class="headerlink" title="密码杂乱无章"></a>密码杂乱无章</h3><p>我们在互联网上有很多的身份，需要很多账号，每一个网站想给你提供服务，基本上都需要一个账号也就是网站对你的唯一标识，这样才能给你提供服务。</p><h3 id="密码保存到浏览器？"><a href="#密码保存到浏览器？" class="headerlink" title="密码保存到浏览器？"></a>密码保存到浏览器？</h3><p>不这个其实也是不安全，而且所有设备只能在浏览器上，而且还必须统一浏览器例如chrome 或者 Firefox 等。</p><p>其次这个浏览器保存的密码，把用来的解密密钥保存在系统里面而且并没有保护，所有在你电脑上运行的软件都能读取这个文件。</p><p>如果你不相信的话<a href="https://github.com/moonD4rk/HackBrowserData" rel="external nofollow noreferrer">HackBrowserData</a>这个程序可以让你直接惊呆，他可以读取浏览器的历史 cookie 以及密码，当然属于安全测试，这个程序没有和我有任何关系。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，我们希望一个安全的，跨平台的，数据在我们自己所保管的、还有免费以及开源。也就只能是 <code>Vaultwarden</code>代替了。</p><p>注意为什么不叫<code>bitwarden</code> 而是叫 <code>Vaultwarden</code> 呢？因为<code>bitwarden</code>是收费的，但是他们家开源自己的api，就有大佬根据他的api 使用rust 进行编写出一个开源的 <code>Vaultwarden</code>。他们可以完美的适配。以下把 <code>Vaultwarden</code>称作为 <code>bitwarden</code></p><h1 id="你需要准备的"><a href="#你需要准备的" class="headerlink" title="你需要准备的"></a>你需要准备的</h1><ul><li>掌握搜索引擎技能（保证一直是最新的知识。）</li><li>一个大脑🧠</li><li>一台能开机的电脑或者是云服务器</li><li>电脑或者是服务器能安装docker，或者你使用Linux 的宝塔</li><li>掌握基本的docker基本知识</li><li>掌握<code>dns</code>解析，申请<code>ssl</code>证书</li></ul><h1 id="搭建开始"><a href="#搭建开始" class="headerlink" title="搭建开始"></a>搭建开始</h1><p>本篇为了，低成本高效部署，选择使用docker，来进行安装。</p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>首先本篇默认，你已经安装完毕docker或者<code>linux</code> 的宝塔面板并且安装了基本的<code>lnmp</code> 服务,如果你这些不会或者不知道的话，可以进行学习完或者也可以跟着本篇尝试跟着做，但是我想进行劝退你们，学习相关知识再来看本篇。</p><p>如果我没有特别指明，宝塔操作的话，都是可以通用的。</p><h3 id="拿到-bitwarden-docker-镜像"><a href="#拿到-bitwarden-docker-镜像" class="headerlink" title="拿到 bitwarden docker 镜像"></a>拿到 bitwarden docker 镜像</h3><p>你可以选择从 <a href="https://hub.docker.com/" rel="external nofollow noreferrer">docker Hub</a> 上进行搜索 vaultwarden/server ，然后进行按照网页上的文档进行克隆。</p><p>或者打开终端输入这段代码</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull vaultwarden/server</span><br></pre></td></tr></tbody></table></figure><blockquote><p>可能有人说这部都一样的吗？我只是选择叫你们 docker hub 是一个镜像仓库，你需要什么可以去这里面搜</p></blockquote><p><img src="https://img.c-dreamer.top/i/1/2023/05/09/6459b00f1d5e1.webp" alt="docker-bitwarden-01"></p><p>我这里拿Windows的终端输出为例，linux上都是一样的大差不大。</p><h3 id="启动前的准备"><a href="#启动前的准备" class="headerlink" title="启动前的准备"></a>启动前的准备</h3><p>拿到镜像就可以准备让程序跑起来了，但是这里我补充一个docker 知识。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name vaultwarden \</span><br><span class="line">  -e ADMIN_TOKEN=some_random_token_as_per_above_explanation \</span><br><span class="line">  -e WEBSOCKET_ENABLED=<span class="literal">true</span> \</span><br><span class="line">  -v /vw-data/:/data/ \</span><br><span class="line">  -p 8081:80 \</span><br><span class="line">  vaultwarden/server:latest</span><br></pre></td></tr></tbody></table></figure><p>上述命令我为了好观看进行格式化，但是扔到部分系统终端上无法进行运行，这段命令仅作为简述</p><ul><li>docker run 是启动一个容器</li><li>–name 是指定容器的名字</li><li>-e 是指定容器环境变量</li><li><code>ADMIN_TOKEN=</code>的环境变量是指定管理员页面的密码。</li><li><code>WEBSOCKET_ENABLED=true</code>启动websocket 让设备在跨平台设备进行实时同步，提高时效性。</li><li>-v 创建一个持久化存储。</li><li><code>vaultwarden/server:latest</code> 是docker 的镜像 lstest是最新的意思</li><li>-p 是映射端口 <strong>最左边的8081是本机端口</strong>，你可以随意更改在<code>0~65535</code>随你喜欢只要端口不被占用即可。</li></ul><p>重点来了：</p><ul><li><code>/vw-data/:/data/</code> 这个首先<code>/vw-data/</code>这个是你本机的文件地址，是用来存储容器产生的数据，例如保存的加密密码都在这个文件夹，这个你需要自己指定你本机的一个位置，一定要记住后面要加<code>/</code>。后面的/data/不需要动了</li></ul><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>根据上面启动前的准备，你需要准备，存储持久化的本机一个文件夹地址，以及一个 admin 管理员密钥，推荐随意生成一个。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name vaultwarden -e ADMIN_TOKEN=123456 -e WEBSOCKET_ENABLED=<span class="literal">true</span> -v /vw-data/:/data/ -p 8081:80 -p 3012:3012 vaultwarden/server:latest</span><br></pre></td></tr></tbody></table></figure><p>把上面的 <code>ADMIN_TOKEN</code>和<code>/vw-data/</code>替换成你的即可</p><p><img src="https://img.c-dreamer.top/i/1/2023/05/09/6459b565d21ad.webp" alt="docker-bitwarden-02.webp"></p><p>运行成功之后，可以访问你的 ip地址（域名）+端口号 即可访问成功，前提是你防火墙开放这个端口。</p><p><img src="https://img.c-dreamer.top/i/1/2023/05/09/6459b5d9da858.webp" alt="docker-bitdaren-03.webp"></p><p>访问可以看到上面的页面，以及你刚才指定的持久化文件夹下面会生成一堆文件</p><p><img src="https://img.c-dreamer.top/i/1/2023/05/09/6459b6240a742.webp" alt="docker-bitwarden-04.webp"></p><p>其中 <code>db.sqlite3</code>是最重要的，这里面存储的你的加密的账号密码数据，希望你妥善保管并且备份。</p><h2 id="反代"><a href="#反代" class="headerlink" title="反代"></a>反代</h2><p>如果你是服务器，切有域名，并且安装了nginx，你可以配置以下反向代理，以宝塔面板为例</p><p>在网站-你自己的网站-设置-反向代理</p><p><img src="https://img.c-dreamer.top/i/1/2023/05/12/645d8d5bc1b83.webp" alt="docker-bitwarden-07.webp"></p><p>端口号是你在运行<code>docker run -p</code>左半面指定的端口号，如果你是跟着教程直接复制的，那么这里端口号为8081，目标url应该写成<code>127.0.0.1:8081</code>。</p><p>然后我们到，<code>nginx</code>的配置文件中，插入以下配置，我这里插入的是第44行，由于每个版本不一样，你可以找到</p><p><code>#引用反向代理规则，注释后配置的反向代理将无效     include /www/server/panel/vhost/nginx/proxy/你的域名/*.conf;</code></p><p>其中 <code>  proxy_pass http:</code>需要根据你自己的环境而言进行配置。</p><p>插入这段话的下方即可然后单击保存。</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /notifications/hub/negotiate {</span><br><span class="line">      <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> <span class="string">"Connection"</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /notifications/hub {</span><br><span class="line">      <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Forwarded <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1:3012;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>这段话是，配置反向代理的ws协议端口。</p><p>现在如果你正确的配置好了域名解析，理论上你只需要访问你的域名即可打开 <code>bitwarden</code> 的页面。</p><h1 id="优雅的使用"><a href="#优雅的使用" class="headerlink" title="优雅的使用"></a>优雅的使用</h1><p>根据上面的搭建你可以已经成功搭建完成并且启动成功，那么我恭喜你，克服了对你的艰难问题。相比你的成功不光全是我的文章，而是你善于思考以及会使用搜索引擎找出一些关键性的问题和报错。</p><h2 id="密码的转移"><a href="#密码的转移" class="headerlink" title="密码的转移"></a>密码的转移</h2><p>由于本篇实在是太长了，而且我太懒了不是很想在继续放图，以及互联网上已经有了轮子我就不在重复制造了。</p><p>如果你英文很好可以去访问：<a href="https://bitwarden.com/help/import-data/" rel="external nofollow noreferrer">Bitwarden</a>官网文档。</p><p>或者你英语不好，可以访问民间翻译的中文文档<a href="https://help.ppgg.in/password-manager/import-and-export/import-data-to-your-vault" rel="external nofollow noreferrer">Bitwarden中文文档</a>。</p><h2 id="客户端的安装"><a href="#客户端的安装" class="headerlink" title="客户端的安装"></a>客户端的安装</h2><p>你可以从官网进行下载：<a href="https://bitwarden.com/download/" rel="external nofollow noreferrer">https://bitwarden.com/download/</a></p><p>这里面有浏览器和客户端。</p><h2 id="客户端的连接"><a href="#客户端的连接" class="headerlink" title="客户端的连接"></a>客户端的连接</h2><p>所有客户端的连接都是一样的，我们需要去设置，更改登录的ur，如果不更改属于官网的。</p><p><img src="https://img.c-dreamer.top/i/1/2023/05/09/6459ba53750db.webp" alt="docker-bitwarden-05.webp"></p><p>在这里填写你的 域名或者是ip + 端口号</p><p><img src="https://img.c-dreamer.top/i/1/2023/05/09/6459ba93037d9.webp" alt="docker-bitwarden-06.webp"></p><p>保存登录即可没有账号的创建账户即可。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://github.com/dani-garcia/vaultwarden/wiki" rel="external nofollow noreferrer">VaultWarden Wiki</a></p><p><a href="https://help.ppgg.in/password-manager/import-and-export/import-data-to-your-vault" rel="external nofollow noreferrer">Bitwarden 帮助中心中文版</a></p><p><a href="https://bitwarden.com/help/import-data/" rel="external nofollow noreferrer">Bitwarden 官方文档</a></p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;blockquote&gt;
&lt;p&gt;本教程是搭建和使用一体的，如果您只是想看如何使用，请直接通过页面的大纲快速跳转。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;过期提醒&quot;&gt;&lt;a href=&quot;#过期提醒&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="docker" scheme="https://blog.ning.moe/tags/docker/"/>
    
    <category term="bitwarden" scheme="https://blog.ning.moe/tags/bitwarden/"/>
    
    <category term="Vaultwarden" scheme="https://blog.ning.moe/tags/Vaultwarden/"/>
    
  </entry>
  
  <entry>
    <title>你可能需要知道的docker 的端口问题。</title>
    <link href="https://blog.ning.moe/posts/DockerSecurity/"/>
    <id>https://blog.ning.moe/posts/DockerSecurity/</id>
    <published>2023-05-04T10:45:07.000Z</published>
    <updated>2024-03-12T16:32:13.689Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>docker 这个东西呢，对于我来说又爱又恨吧，爱的事情是可以很快速的进行部署项目，解决一些复杂和繁琐的问题，这也是docker 设计的初衷。恨得呢，本身我对于docker 来说是是一个小白用户，我只会 docker run xxxx 来完成我在github 找到的有趣应用，但是出了问题的时候，我需要去使用搜索引擎查阅的知识。</p><h1 id="需要准备的东西？"><a href="#需要准备的东西？" class="headerlink" title="需要准备的东西？"></a>需要准备的东西？</h1><ul><li>掌握搜索引擎技能（下面的文章只会叫你如何进行使用基本的iptables）</li><li>一个大脑🧠</li><li>一台运行了Linux系统的电脑</li><li>掌握基本的Linux基本知识</li></ul><h1 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h1><p>应该在阅读这篇文章的人，都在很疑惑，为什么我在docker上使用 docker run -p 指令的时候，和宿主机进行绑定端口，本来我是想使用nginx 进行反代的，我自己的防火墙也没有放行这个端口，但从外部确确实实的可以访问。</p><h1 id="为什么会出现这个问题？"><a href="#为什么会出现这个问题？" class="headerlink" title="为什么会出现这个问题？"></a>为什么会出现这个问题？</h1><p>在docker 官方文档上就有这个解释，docker 使用 -p 进行放行端口的时候，低层使用 <code>iptables防火墙 FORWARD</code>将流量转发到docker 运行的容器里面。</p><p>我拿 <a href="https://www.c-dreamer.top/posts/IPtables/#%E5%9B%9B%E8%A1%A8%E9%A1%BA%E5%BA%8F" rel="external nofollow noreferrer">Iptables防火墙</a> 这篇文章的图进行来说明一下</p><p><img src="https://img.c-dreamer.top/i/1/2023/01/30/63d77669edb42.webp" alt="iptables.png"></p><p>因为 流量在进入iptables 防火墙的时候 会经过路由选择进行判定，这个流量是要转发还是要流入本机里面，由于docker 自身创建了一个单独的内网环境一般这个 IP段是 <code>172.17.0.0/16</code> ,然后流浪回去转入对应的容器里面。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>知道了为什么会出现这个问题，其实就可以知道其中一种解决办法了，就是不适用 -p 指令不让宿主机和容器进行绑定，然后使用nginx 进行，反向代理就可以了，一般情况下是，docker 使用 桥接网络模式 ，Docker 会为每个容器分配一个唯一的 IP 地址。可以查询这个docker 容器的ip 就可以实现反代，但是这个方法会有些问题，</p><ol><li>有点麻烦，你需要创建一个docker 容器就要进行配置反代。</li><li> nginx 不支持 udp 代理所以说还要安装和配置能代理udp 的软件实现反代。</li><li>还有一种办法就是直接在docker 的配置文件中关闭使用 IP tables 防护墙，交给其他防火墙进行保护例如 ufw 等</li></ol><h2 id="方法一：-nginx-反向代理"><a href="#方法一：-nginx-反向代理" class="headerlink" title="方法一： nginx 反向代理"></a>方法一： nginx 反向代理</h2><p>使用这个方法需要拿到容器的IP</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect &lt;你的容器唯一<span class="built_in">id</span>或者容器的名字&gt; | grep <span class="string">"IPAddress"</span></span><br></pre></td></tr></tbody></table></figure><p>应该会返回，一下信息，例如我的这个测试容器的IP就是 <code>172.17.0.4</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker inspect nginx-8080 | grep <span class="string">"IPAddress"</span></span><br><span class="line">            <span class="string">"SecondaryIPAddresses"</span>: null,</span><br><span class="line">            <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.4"</span>,</span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.4"</span>,</span><br></pre></td></tr></tbody></table></figure><p>然后去你的nginx 配置新增你的配置文件</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server</span> {</span><br><span class="line">    <span class="string">listen</span> <span class="number">80</span><span class="string">;</span> <span class="string">//监听端口</span></span><br><span class="line">    <span class="string">server_name</span> <span class="string">localhost;</span> <span class="string">//</span> <span class="string">localhost</span> <span class="string">是监听域名或者是ip</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">location</span> <span class="string">/</span> {</span><br><span class="line">        <span class="string">proxy_pass</span> <span class="string">http://容器的IP地址:容器内部Nginx服务器监听的端口;</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果你是使用BT面板进行管理的，只需要去网站 - 创建一个新的站点，然后打开配置选择反向代理，填入对应信息即可。</p><h2 id="方法二：-修改docker-配置文件"><a href="#方法二：-修改docker-配置文件" class="headerlink" title="方法二： 修改docker 配置文件"></a>方法二： 修改docker 配置文件</h2><p>这个方法就比较简单和直接，一般默认情况下docker 的配置文件会在  <code> /etc/docker/daemon.json</code> 如果没有这个 <code>daemon.json</code>可以直接创建就行了。</p><p>注意如果你不会使用vi 或者是vim 编辑器的基本使用，你应该需要去学习一下vi或者vim 的简单使用即可。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/docker/daemon.json</span><br></pre></td></tr></tbody></table></figure><p>加入这段配置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="string">"iptables"</span>: <span class="literal">false</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>重启一下docker 以及docker 的守护进程</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></tbody></table></figure><p>注意重启 docker 和docker的守护进程，会需要手动重启创建的docker 容器。在docker 容器重新启动之后 -p 只会绑定宿主机端口号，宿主机端口受现在防火墙进行管理。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;docker 这个东西呢，对于我来说又爱又恨吧，爱的事情是可以很快速的进行部署项目，解决一</summary>
      
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="docker" scheme="https://blog.ning.moe/tags/docker/"/>
    
    <category term="安全" scheme="https://blog.ning.moe/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="ufw" scheme="https://blog.ning.moe/tags/ufw/"/>
    
    <category term="IPtables" scheme="https://blog.ning.moe/tags/IPtables/"/>
    
    <category term="防火墙" scheme="https://blog.ning.moe/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
    <category term="firewall" scheme="https://blog.ning.moe/tags/firewall/"/>
    
  </entry>
  
  <entry>
    <title>御坂美琴生日快乐</title>
    <link href="https://blog.ning.moe/posts/MisakaMikoto/"/>
    <id>https://blog.ning.moe/posts/MisakaMikoto/</id>
    <published>2023-05-01T16:00:00.000Z</published>
    <updated>2024-03-12T16:32:13.691Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><blockquote><p><strong>你指间闪烁的电光，是我此生不变的信仰唯有这超电磁炮将永世长存！！！</strong></p></blockquote><h1 id="首先-祝姐姐大人生日快乐，又一年生日到啦吗，真快呀。"><a href="#首先-祝姐姐大人生日快乐，又一年生日到啦吗，真快呀。" class="headerlink" title="首先,祝姐姐大人生日快乐，又一年生日到啦吗，真快呀。"></a>首先,祝姐姐大人生日快乐，又一年生日到啦吗，真快呀。</h1><img src="https://img.c-dreamer.top/i/1/2023/05/01/644f7e2e4fa62.webp" alt="d6e89b5.webp" style="zoom:50%;"><img src="https://img.c-dreamer.top/i/1/2023/05/01/644f7e24d2d9a.webp" alt="7606d4f59bf.webp" style="zoom:50%;"><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><h2 id="对我个人："><a href="#对我个人：" class="headerlink" title="对我个人："></a>对我个人：</h2><p>我已经是一个入宅很晚很晚的人了，我的入宅番是 <code>约战</code> 我并不是完完全全的 某科学的 世界的粉丝，我也并没有看过魔法禁书目录，我仅对于 超电磁炮 御坂美琴的热爱。</p><blockquote><p>摘抄一部分萌娘百科的话。</p><p>天真活泼、爱唠叨的14岁元气少女。有着一头及肩的茶色发丝、同样是茶色的瞳孔、绝不服输的眼神、不需要化妆也很俏丽的面孔。因为外形秀丽加上成绩优秀，因此成为校内学生心目中的偶像，甚至会被学妹们尊称为“御坂大人”。平素都是穿着常盘台的制服，而裙底的安全裤则是美琴活泼的象征。性格好胜、正义感强，有着男孩子般的爽朗性格，但是尤其是在面对可爱的东西时，就显得缺乏耐心、非常不坦率。当喜欢的东西（呱太）或中意的东西被别人评价说“太儿童化”的时候，都会义正言辞地的否决，然后愉♂悦地享受。紧张时会蹦出“喵”的口癖，并且在担心他人慌乱时会自称“美琴姐姐”</p></blockquote><h2 id="对于B站："><a href="#对于B站：" class="headerlink" title="对于B站："></a>对于B站：</h2><p>虽然我入宅很晚，我接触B站也是比较晚了，但最近几年B站环境都是人尽皆知的事情了，对于 B站往年 不管是对 美琴的庆生 还是对其他知名的动漫人物，都是在发的，对于去年B站没有给美琴庆生以及其他人物，我表示非常是生气也表示非常的无奈，但对于今年B站的改变，对于庆生很早就开始宣传了，但并不是 哔哩哔哩弹幕网 这个账号进行宣传，而是 哔哩哔哩番剧组和哔哩哔哩会员购 进行宣传的。剩下的我就不想多说了，B站快要嗝屁的时候还想在收割一波自己以前最老以及起家的人，怎么说呢。从以前B站属于二次元的天地，到最后 二次元滚出B站。</p><p>可能以前 别人说我是二刺螈 我表示可能会有点开心，但对于近几年 <strong>滚，老子不是二次元</strong></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>时间会磨损一切，那么我又能坚持多久呢？</p><h1 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h1><p> 萌娘百科：<a href="https://zh.moegirl.org.cn/%E5%BE%A1%E5%9D%82%E7%BE%8E%E7%90%B4" rel="external nofollow noreferrer">御坂美琴人物简介</a></p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;你指间闪烁的电光，是我此生不变的信仰唯有这超电磁炮将永世长存！！！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;首先-祝姐姐大人生日快乐，又一年生日到啦吗，</summary>
      
    
    
    
    <category term="生活随想" scheme="https://blog.ning.moe/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="Misaka" scheme="https://blog.ning.moe/tags/Misaka/"/>
    
    <category term="御坂美琴" scheme="https://blog.ning.moe/tags/%E5%BE%A1%E5%9D%82%E7%BE%8E%E7%90%B4/"/>
    
    <category term="某科学的" scheme="https://blog.ning.moe/tags/%E6%9F%90%E7%A7%91%E5%AD%A6%E7%9A%84/"/>
    
  </entry>
  
  <entry>
    <title>Hexo butterfly 优化</title>
    <link href="https://blog.ning.moe/posts/butterfly/"/>
    <id>https://blog.ning.moe/posts/butterfly/</id>
    <published>2023-04-22T02:30:20.000Z</published>
    <updated>2024-03-12T16:32:13.692Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>我也来水一篇博文吧，最近我也不知道在忙什么（<del>明明就是懒得更新</del>），也感谢  @<a href="https://yujie.pro/network/52.html" rel="external nofollow noreferrer">夜灭</a>博主,让我可以水一篇博文以及再次优化hexo博客，如你所见我的博客在国内访问基本上都能在5秒以内完成这个所有加载。</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="博客基本情况"><a href="#博客基本情况" class="headerlink" title="博客基本情况"></a>博客基本情况</h2><p>优化过的情况</p><ol><li>源站在GitHub Pages上</li><li>使用双解析模式（国内 腾讯云 国外Cloudflare）</li><li>把 hexo 需要的静态js 资源全部缓存到源站，不在走<code>jsdelivr</code></li><li>图床使用自建数据在<code>backblaze</code>存储桶上，详细的图床解决方案：<a href="https://blog.ning.moe/posts/lskypro-backblaze/">https://blog.ning.moe/posts/lskypro-backblaze/</a></li><li>图床使用cf的自定义域名进行双解析和第二点一样。</li></ol><p><img src="https://img.c-dreamer.top/i/1/2023/04/22/64439fea99b29.webp" alt="图.webp"></p><h2 id="butterfly-静态资源优化"><a href="#butterfly-静态资源优化" class="headerlink" title="butterfly 静态资源优化"></a>butterfly 静态资源优化</h2><p>在最新的 <code>butterfly </code>4.8.1 中加入了自定义cdn 功能，虽然以前也能改那就要一个一个配置文件上改了</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CDN:</span></span><br><span class="line">  <span class="comment"># The CDN provider of internal scripts (主題內部 js 的 cdn 配置)</span></span><br><span class="line">  <span class="comment"># option: local/jsdelivr/unpkg/cdnjs/custom</span></span><br><span class="line">  <span class="comment"># Dev version can only choose. ( dev版的主題只能設置為 local )</span></span><br><span class="line">  <span class="attr">internal_provider:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># The CDN provider of third party scripts (第三方 js 的 cdn 配置)</span></span><br><span class="line">  <span class="comment"># option: local/jsdelivr/unpkg/cdnjs/custom</span></span><br><span class="line">  <span class="comment"># when set it to local, you need to install hexo-butterfly-extjs</span></span><br><span class="line">  <span class="attr">third_party_provider:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Add version number to url, true or false</span></span><br><span class="line">  <span class="attr">version:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Custom format</span></span><br><span class="line">  <span class="comment"># For example: https://cdn.staticfile.org/${cdnjs_name}/${version}/${min_cdnjs_file}</span></span><br><span class="line">  <span class="attr">custom_format:</span> </span><br><span class="line">  <span class="comment">#以下省略</span></span><br></pre></td></tr></tbody></table></figure><p>我这里使用了 <code>local</code>的CDN就是把所有资源封装在本地了，你需要执行<code>npm install hexo-butterfly-extjs</code>命令，hexo 三连命令即可<code>hexo cl &amp;&amp; hexo  generate &amp;&amp; hexo server</code>。</p><p>如果你不喜欢这样的话，<a href="https://butterfly.js.org/posts/ceeb73f/#CDN" rel="external nofollow noreferrer">可以参考主题官方提供的配置</a>,可以选择如 七牛云 BootCDN Elemecdn 等<br>但是这个配置其他cdn 我测试的时候偶尔也会丢失一部分静态资源。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我也来水一篇博文吧，最近我也不知道在忙什么（&lt;del&gt;明明就是懒</summary>
      
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="hexo" scheme="https://blog.ning.moe/tags/hexo/"/>
    
    <category term="butterfly" scheme="https://blog.ning.moe/tags/butterfly/"/>
    
    <category term="jsdelivr" scheme="https://blog.ning.moe/tags/jsdelivr/"/>
    
    <category term="CDN" scheme="https://blog.ning.moe/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>Java使用CloudFlare Turnstile 验证码</title>
    <link href="https://blog.ning.moe/posts/Java-CAPTCHA-cloudflare/"/>
    <id>https://blog.ning.moe/posts/Java-CAPTCHA-cloudflare/</id>
    <published>2023-03-28T02:13:46.000Z</published>
    <updated>2024-03-12T16:32:13.690Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h1><blockquote><p>在学习springMVC 和Spring Security中，总有一个服务，叫做验证码，每次我自己写这个验证码的时候，最后还要在测试，而且特别的不友好，甚至我自己都分不清那个字母，当然Java里面有个很优秀的滑块验证码比如这个大佬开发的<a href="https://gitee.com/tianai/tianai-captcha" rel="external nofollow noreferrer">tianai-captcha</a><br>总是给人一种不是很优雅，我自己是人类，为什么还要进行验证码，而且这种验证往往经过训练的ai更容易比人类做的好，这就失去了验证码的意义<code>CAPTCHA</code>，Cloud Flare就做了一个无需进行让你输入字符或者滑动以及选择图片的验证码，如果需要更多了解你可以访问CF的官方介绍<a href="https://blog.cloudflare.com/zh-cn/turnstile-private-captcha-alternative-zh-cn/" rel="external nofollow noreferrer">CloudFlare-Turnstile</a></p></blockquote><h1 id="需要准备"><a href="#需要准备" class="headerlink" title="需要准备"></a>需要准备</h1><ol><li>一个Cloud Flare账号</li><li>一个域名（不需要接入Cloud Flare）<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1></li></ol><blockquote><p>CloudFlare以下简称CF， 官网的配置文件已经写的很清楚<br> <img src="https://img.misaka.pics/i/1/2023/04/21/64423eac7e80f.webp" alt="Turnstile" style="zoom: 67%;"></p><ol><li>用户打开受验证码保护的网页，先会和CF的验证码服务器进行通讯拿到，JWT令牌（令牌有效300秒）</li><li>用户会把提交内容以及CF生成的令牌发送到服务器，</li><li>服务器会拿着CF令牌进行和CF验证码服务器通讯，拿到JSON数值</li></ol></blockquote><h1 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h1><ol><li>登录你的CF账号会在仪表盘的左侧看到<code>Turnstile </code></li><li>点击添加</li><li><img src="https://img.misaka.pics/i/1/2023/03/28/6422b39497161.webp" alt="image-20230328110719966" style="zoom:50%;"></li></ol><p>我一般是选择托管，由cf来决定用户需不需要进行交互一下，</p><ol start="4"><li>注册完毕之后我们会得到两个值一个是站点密钥，一个是密钥，密钥是用来进行服务端和CF通讯的，而站点密钥是放在被保护的资源上的。</li></ol><p>按照<a href="https://developers.cloudflare.com/turnstile/get-started/client-side-rendering/" rel="external nofollow noreferrer">CF文档的客户端配置</a>我这里就那官方的例子来</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引用CF的验证码js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://challenges.cloudflare.com/turnstile/v0/api.js"</span> <span class="attr">async</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form"</span> <span class="attr">action</span>=<span class="string">"/login"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在data-sitekey中需要填写站点密钥 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cf-turnstile"</span> <span class="attr">data-sitekey</span>=<span class="string">"0x4AAAAAAACzpeJEUBQ4rBi-"</span> <span class="attr">data-callback</span>=<span class="string">"javascriptCallback"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>&gt;</span>Log in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>用户单击的登陆之后我们就能在后端拿到用户的账号密码以及CF的令牌。我们会在后端拿到一个名为：<code>cf-turnstile-response</code>的键值对，这里面存放的是cf的令牌。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String req)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line"><span class="comment">//secret 是填写密钥</span></span><br><span class="line"><span class="type">String</span> <span class="variable">secret</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line"><span class="comment">//url是默认的地址无需更改</span></span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">"https://challenges.cloudflare.com/turnstile/v0/siteverify"</span>);</span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">httpConn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">httpConn.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line"><span class="comment">//请求类型cf 请求仅支持 application/x-www-form-urlencoded 或者是 application/JSON</span></span><br><span class="line">httpConn.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"></span><br><span class="line">httpConn.setDoOutput(<span class="literal">true</span>);</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(httpConn.getOutputStream());</span><br><span class="line">writer.write(<span class="string">"secret="</span>+secret+<span class="string">"&amp;response="</span>+req);</span><br><span class="line">writer.flush();</span><br><span class="line">writer.close();</span><br><span class="line">httpConn.getOutputStream().close();</span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">responseStream</span> <span class="operator">=</span> httpConn.getResponseCode() / <span class="number">100</span> == <span class="number">2</span></span><br><span class="line">? httpConn.getInputStream()</span><br><span class="line">: httpConn.getErrorStream();</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(responseStream).useDelimiter(<span class="string">"\\A"</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">System.out.println(response);</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述是我们拿到用户的<code>cf-turnstile-response</code>值然后和cf通讯返回的<code>response</code>就是CF给我们的JSON。</p><p>根据官方文档：</p><p>如果验证成功，响应应类似于以下内容：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"success"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"challenge_ts"</span><span class="punctuation">:</span> <span class="string">"2022-02-28T15:14:30.096Z"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"hostname"</span><span class="punctuation">:</span> <span class="string">"example.com"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"error-codes"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"action"</span><span class="punctuation">:</span> <span class="string">"login"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"cdata"</span><span class="punctuation">:</span> <span class="string">"sessionid-123456789"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>challenge_ts</code>是解决挑战时的 ISO 时间戳。</li><li><code>hostname</code>是为其提供质询的主机名。</li><li><code>action</code>是传递给客户端小部件的客户小部件标识符。这用于区分在分析中使用相同站点密钥的小部件。它的完整性受到攻击者修改的保护。建议验证操作是否与预期值匹配。</li><li><code>cdata</code>是传递给客户端小部件的客户数据。客户可以使用它来传达状态。它的完整性受到攻击者修改的保护。</li><li><code>error-codes</code>是发生的错误列表。</li></ul><p>如果验证失败，响应应类似于以下内容：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"success"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"error-codes"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">"invalid-input-response"</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p><code>success</code>通过将属性设置为 来指示验证错误<code>false</code>。提供了错误代码列表以指示响应无法验证的原因。响应还可能包含其他字段，具体取决于 Turnstile siteverify 是否能够成功或不成功地解析响应。</p><p> <strong>错误代码</strong>：</p><table><thead><tr><th align="left">错误代码</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>missing-input-secret</code></td><td align="left">未传递秘密参数。</td></tr><tr><td align="left"><code>invalid-input-secret</code></td><td align="left">秘密参数无效或不存在。</td></tr><tr><td align="left"><code>missing-input-response</code></td><td align="left">未传递响应参数。</td></tr><tr><td align="left"><code>invalid-input-response</code></td><td align="left">响应参数无效或已过期。</td></tr><tr><td align="left"><code>bad-request</code></td><td align="left">该请求被拒绝，因为它格式不正确。</td></tr><tr><td align="left"><code>timeout-or-duplicate</code></td><td align="left">响应参数之前已经过验证。</td></tr><tr><td align="left"><code>internal-error</code></td><td align="left">验证响应时发生内部错误。可以重试该请求。</td></tr></tbody></table><p>根据以上信息我们就可以判断并且，接收cf的保护了。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p><a href="https://developers.cloudflare.com/turnstile/" rel="external nofollow noreferrer">CF Turnstile 开发文档</a><br><a href="https://blog.cloudflare.com/zh-cn/turnstile-private-captcha-alternative-zh-cn/" rel="external nofollow noreferrer">CloudFlare-Turnstile介绍</a></p></blockquote></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;引言：&quot;&gt;&lt;a href=&quot;#引言：&quot; class=&quot;headerlink&quot; title=&quot;引言：&quot;&gt;&lt;/a&gt;引言：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在学习springMVC 和Spring Securit</summary>
      
    
    
    
    <category term="网络技术" scheme="https://blog.ning.moe/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="CloudFlare" scheme="https://blog.ning.moe/tags/CloudFlare/"/>
    
    <category term="Spring" scheme="https://blog.ning.moe/tags/Spring/"/>
    
    <category term="Java" scheme="https://blog.ning.moe/tags/Java/"/>
    
    <category term="CAPTCHA" scheme="https://blog.ning.moe/tags/CAPTCHA/"/>
    
  </entry>
  
</feed>
